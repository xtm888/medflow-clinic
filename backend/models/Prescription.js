const mongoose = require('mongoose');

const prescriptionSchema = new mongoose.Schema({
  // Identification
  prescriptionId: {
    type: String,
    unique: true
    // Not required - auto-generated by pre-save hook
  },

  // Patient and Provider
  patient: {
    type: mongoose.Schema.ObjectId,
    ref: 'Patient',
    required: true
  },
  prescriber: {
    type: mongoose.Schema.ObjectId,
    ref: 'User',
    required: true
  },
  visit: {
    type: mongoose.Schema.ObjectId,
    ref: 'Visit'
    // Not required - prescriptions can be created without a visit
  },
  appointment: {
    type: mongoose.Schema.ObjectId,
    ref: 'Appointment'
  },

  // Invoice reference (auto-generated when prescription is dispensed)
  invoice: {
    type: mongoose.Schema.ObjectId,
    ref: 'Invoice'
  },

  // Prescription Type
  type: {
    type: String,
    enum: ['medication', 'optical', 'therapy', 'medical-device', 'lab-test'],
    required: true
  },

  // Status
  status: {
    type: String,
    enum: ['draft', 'pending', 'ready', 'partial', 'dispensed', 'cancelled', 'expired'],
    default: 'pending'
  },

  // Pharmacy workflow status
  pharmacyStatus: {
    type: String,
    enum: ['pending', 'reviewing', 'preparing', 'ready', 'dispensed', 'issue'],
    default: 'pending'
  },

  // Dates
  dateIssued: {
    type: Date,
    default: Date.now,
    required: true
  },
  validUntil: {
    type: Date,
    required: true
  },

  // Medications (fully integrated with inventory and safety checks)
  medications: [{
    // References to master data
    drug: {
      type: mongoose.Schema.ObjectId,
      ref: 'Drug'
      // Not required - allows manual medication entries without drug reference
    },
    inventoryItem: {
      type: mongoose.Schema.ObjectId,
      ref: 'PharmacyInventory'
    },

    // Basic prescription details
    name: String, // Display name (auto-populated from drug)
    genericName: String, // Auto-populated from drug
    brand: String,
    strength: String,
    form: String,
    route: String,

    // Dosage instructions
    dosage: {
      amount: Number,
      unit: String,
      frequency: {
        times: Number,
        period: String // "day", "week", "month"
      },
      duration: {
        value: Number,
        unit: String // "days", "weeks", "months"
      },
      timing: [String], // "morning", "afternoon", "evening", "bedtime"
      withFood: {
        type: String,
        enum: ['before', 'with', 'after', 'empty-stomach', 'anytime']
      }
    },

    // Quantity prescribed
    quantity: {
      type: Number,
      required: true
    },
    unit: String,

    // Instructions
    instructions: String,
    indication: String,

    // Refills
    refills: {
      allowed: {
        type: Number,
        default: 0
      },
      remaining: {
        type: Number,
        default: 0
      }
    },
    substitutionAllowed: {
      type: Boolean,
      default: true
    },

    // Inventory reservation
    reservation: {
      reservationId: String,
      reservedQuantity: Number,
      reservedAt: Date,
      reservedBatches: [{
        lotNumber: String,
        quantity: Number,
        expirationDate: Date
      }],
      status: {
        type: String,
        enum: ['pending', 'reserved', 'fulfilled', 'cancelled'],
        default: 'pending'
      }
    },

    // Safety checks (auto-populated during prescription creation)
    safetyChecks: {
      allergies: [{
        allergen: String,
        severity: String,
        matched: Boolean
      }],
      interactions: [{
        withDrug: String,
        severity: String,
        description: String
      }],
      contraindications: [{
        condition: String,
        severity: String,
        description: String
      }],
      warnings: [String],
      checksPerformedAt: Date,
      overridden: Boolean,
      overrideReason: String,
      overrideBy: {
        type: mongoose.Schema.ObjectId,
        ref: 'User'
      }
    },

    // Dispensing tracking
    dispensing: {
      dispensed: {
        type: Boolean,
        default: false
      },
      dispensedQuantity: Number,
      dispensedBatches: [{
        lotNumber: String,
        quantity: Number,
        expirationDate: Date
      }],
      dispensedBy: {
        type: mongoose.Schema.ObjectId,
        ref: 'User'
      },
      dispensedAt: Date,
      pharmacyNotes: String
    },

    // Pricing (from inventory at time of prescription)
    pricing: {
      unitPrice: Number,
      totalCost: Number,
      currency: {
        type: String,
        default: 'CFA'
      }
    }
  }],

  // Optical Prescription
  optical: {
    prescriptionType: {
      type: String,
      enum: ['glasses', 'contacts', 'both']
    },
    // Right Eye (OD)
    OD: {
      sphere: Number,
      cylinder: Number,
      axis: Number,
      add: Number,
      prism: String,
      base: String,
      va: String, // visual acuity
      // Contact lens specific
      baseCurve: Number,
      diameter: Number,
      brand: String
    },
    // Left Eye (OS)
    OS: {
      sphere: Number,
      cylinder: Number,
      axis: Number,
      add: Number,
      prism: String,
      base: String,
      va: String,
      // Contact lens specific
      baseCurve: Number,
      diameter: Number,
      brand: String
    },
    // Pupillary Distance
    pd: {
      binocular: Number,
      monocular: {
        OD: Number,
        OS: Number
      }
    },
    // Additional measurements
    vertexDistance: Number,
    pantoscopicTilt: Number,
    frameWrap: Number,
    // Lens recommendations
    lensType: String, // single vision, bifocal, progressive, etc.
    lensMaterial: String,
    lensCoatings: [String],
    tint: String,
    specialInstructions: String
  },

  // Diagnosis
  diagnosis: [{
    code: String, // ICD-10 code
    description: String
  }],

  // Instructions
  instructions: {
    general: String,
    patient: String,
    pharmacy: String
  },

  // Allergies and Warnings
  allergies: [String],
  warnings: [String],
  precautions: [String],

  // Dispensing Information
  dispensing: [{
    dispensedBy: {
      type: mongoose.Schema.ObjectId,
      ref: 'User'
    },
    dispensedAt: Date,
    pharmacy: {
      name: String,
      address: String,
      phone: String
    },
    quantity: Number,
    daysSupply: Number,
    lotNumber: String,
    expirationDate: Date,
    copayAmount: Number,
    totalCost: Number,
    notes: String
  }],

  // Insurance
  insurance: {
    used: {
      type: Boolean,
      default: false
    },
    provider: String,
    policyNumber: String,
    groupNumber: String,
    bin: String,
    pcn: String,
    priorAuthRequired: Boolean,
    priorAuthNumber: String,
    coverageStatus: String
  },

  // E-Prescription Details
  ePrescription: {
    enabled: {
      type: Boolean,
      default: false
    },
    transmittedAt: Date,
    transmissionId: String,
    sentTo: {
      pharmacy: String,
      ncpdpId: String
    },
    status: String,
    errorMessage: String
  },

  // Verification
  verification: {
    required: {
      type: Boolean,
      default: false
    },
    verifiedBy: {
      type: mongoose.Schema.ObjectId,
      ref: 'User'
    },
    verifiedAt: Date,
    method: String, // manual, automatic, phone
    notes: String
  },

  // Controlled Substance Info
  controlledSubstance: {
    schedule: {
      type: String,
      enum: ['I', 'II', 'III', 'IV', 'V']
    },
    deaNumber: String,
    stateControlledSubstanceNumber: String
  },

  // Signature
  signature: {
    prescriber: {
      signed: {
        type: Boolean,
        default: false
      },
      signedAt: Date,
      signatureData: String // Base64 encoded signature image
    },
    patient: {
      signed: Boolean,
      signedAt: Date,
      signatureData: String
    }
  },

  // Notes
  notes: {
    clinical: String,
    pharmacy: String,
    internal: String
  },

  // Cancellation
  cancellation: {
    cancelled: {
      type: Boolean,
      default: false
    },
    cancelledAt: Date,
    cancelledBy: {
      type: mongoose.Schema.ObjectId,
      ref: 'User'
    },
    reason: String
  },

  // Renewal
  renewal: {
    isRenewal: {
      type: Boolean,
      default: false
    },
    originalPrescription: {
      type: mongoose.Schema.ObjectId,
      ref: 'Prescription'
    },
    renewalRequested: Boolean,
    renewalRequestedAt: Date,
    renewalApproved: Boolean,
    renewalApprovedBy: {
      type: mongoose.Schema.ObjectId,
      ref: 'User'
    },
    renewalApprovedAt: Date
  },

  // Communication
  communications: [{
    type: {
      type: String,
      enum: ['patient-query', 'pharmacy-query', 'clarification', 'change-request']
    },
    from: String,
    to: String,
    message: String,
    response: String,
    timestamp: Date,
    resolved: Boolean
  }],

  // Audit
  createdBy: {
    type: mongoose.Schema.ObjectId,
    ref: 'User'
  },
  updatedBy: {
    type: mongoose.Schema.ObjectId,
    ref: 'User'
  },
  viewHistory: [{
    viewedBy: {
      type: mongoose.Schema.ObjectId,
      ref: 'User'
    },
    viewedAt: Date,
    action: String
  }],

  // Optimistic locking - prevents lost updates from concurrent modifications
  version: {
    type: Number,
    default: 0
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true },
  optimisticConcurrency: true,
  versionKey: 'version'
});

// Indexes
prescriptionSchema.index({ patient: 1, dateIssued: -1 });
prescriptionSchema.index({ prescriber: 1, status: 1 });
prescriptionSchema.index({ prescriptionId: 1 });
prescriptionSchema.index({ type: 1, status: 1 });
prescriptionSchema.index({ validUntil: 1 });

// Virtual for isExpired
prescriptionSchema.virtual('isExpired').get(function() {
  return new Date() > this.validUntil;
});

// Virtual for daysUntilExpiry
prescriptionSchema.virtual('daysUntilExpiry').get(function() {
  const today = new Date();
  const expiry = new Date(this.validUntil);
  const diffTime = expiry - today;
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  return diffDays;
});

// CRITICAL: Validate dates to prevent future dates
prescriptionSchema.pre('save', function(next) {
  const now = new Date();

  // Prescription issue date should not be in the future
  if (this.dateIssued && new Date(this.dateIssued) > now) {
    const error = new Error('Prescription issue date cannot be in the future');
    error.name = 'ValidationError';
    error.statusCode = 400;
    return next(error);
  }

  // Dispensing dates should not be in the future
  if (this.dispensing && this.dispensing.length > 0) {
    for (const dispensingRecord of this.dispensing) {
      if (dispensingRecord.dispensedAt && new Date(dispensingRecord.dispensedAt) > now) {
        const error = new Error('Dispensing date cannot be in the future');
        error.name = 'ValidationError';
        error.statusCode = 400;
        return next(error);
      }
    }
  }

  // Medication dispensing dates should not be in the future
  if (this.medications && this.medications.length > 0) {
    for (const medication of this.medications) {
      if (medication.dispensing?.dispensedAt && new Date(medication.dispensing.dispensedAt) > now) {
        const error = new Error('Medication dispensing date cannot be in the future');
        error.name = 'ValidationError';
        error.statusCode = 400;
        return next(error);
      }

      if (medication.reservation?.reservedAt && new Date(medication.reservation.reservedAt) > now) {
        const error = new Error('Reservation date cannot be in the future');
        error.name = 'ValidationError';
        error.statusCode = 400;
        return next(error);
      }
    }
  }

  next();
});

// Generate prescription ID
prescriptionSchema.pre('save', async function(next) {
  if (!this.prescriptionId) {
    const date = new Date();
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const count = await this.constructor.countDocuments({
      dateIssued: {
        $gte: new Date(year, date.getMonth(), 1),
        $lt: new Date(year, date.getMonth() + 1, 1)
      }
    });

    const typePrefix = {
      'medication': 'MED',
      'optical': 'OPT',
      'therapy': 'THR',
      'medical-device': 'DEV',
      'lab-test': 'LAB'
    };

    const prefix = typePrefix[this.type] || 'RX';
    this.prescriptionId = `${prefix}${year}${month}${String(count + 1).padStart(5, '0')}`;
  }

  // Set default validity period if not specified
  if (!this.validUntil) {
    const validityDays = this.type === 'optical' ? 365 : 90; // 1 year for optical, 90 days for medication
    this.validUntil = new Date(Date.now() + validityDays * 24 * 60 * 60 * 1000);
  }

  // Update status based on expiry
  if (this.isExpired && this.status === 'active') {
    this.status = 'expired';
  }

  next();
});

// Check drug interactions
prescriptionSchema.methods.checkInteractions = async function(patientId) {
  // This would integrate with a drug interaction API
  // Placeholder for actual implementation
  const Patient = mongoose.model('Patient');
  const patient = await Patient.findById(patientId).populate('medications');

  const interactions = [];
  // Check logic would go here

  return interactions;
};

// Format for printing
prescriptionSchema.methods.formatForPrint = function() {
  const formatted = {
    prescriptionId: this.prescriptionId,
    date: this.dateIssued.toLocaleDateString(),
    patient: this.populated('patient') || this.patient,
    prescriber: this.populated('prescriber') || this.prescriber,
    validUntil: this.validUntil.toLocaleDateString()
  };

  if (this.type === 'medication') {
    formatted.medications = this.medications.map(med => ({
      name: med.name,
      dosage: `${med.strength} - ${med.dosage}`,
      instructions: `${med.frequency} for ${med.duration}`,
      quantity: `${med.quantity} ${med.unit}`,
      refills: med.refills.allowed
    }));
  } else if (this.type === 'optical') {
    formatted.optical = {
      OD: this.optical.OD,
      OS: this.optical.OS,
      pd: this.optical.pd,
      add: this.optical.OD.add || this.optical.OS.add
    };
  }

  return formatted;
};

// Reserve inventory for all medications in prescription
// NOW WITH TRANSACTION SUPPORT
prescriptionSchema.methods.reserveInventory = async function(userId, session = null) {
  if (this.type !== 'medication' || !this.medications || this.medications.length === 0) {
    return { success: true, message: 'No medications to reserve' };
  }

  const PharmacyInventory = require('./PharmacyInventory');
  const results = [];

  for (const medication of this.medications) {
    if (!medication.inventoryItem) {
      results.push({
        medicationName: medication.name,
        success: false,
        error: 'No inventory item linked'
      });
      continue;
    }

    try {
      // Use session for transaction support
      const inventoryItem = await PharmacyInventory.findById(medication.inventoryItem).session(session);
      if (!inventoryItem) {
        results.push({
          medicationName: medication.name,
          success: false,
          error: 'Inventory item not found'
        });
        continue;
      }

      // Reserve stock using PharmacyInventory's reserveStock method (with session)
      const reservation = await inventoryItem.reserveStock(
        medication.quantity,
        'prescription',
        this._id,
        'Prescription',
        userId,
        session  // Pass session to reserveStock
      );

      // Update medication with reservation details
      medication.reservation = {
        reservationId: reservation.reservationId,
        reservedQuantity: reservation.quantity,
        reservedAt: new Date(),
        reservedBatches: reservation.batches.map(b => ({
          lotNumber: b.lotNumber,
          quantity: b.quantity,
          expirationDate: inventoryItem.batches.find(ib => ib.lotNumber === b.lotNumber)?.expirationDate
        })),
        status: 'reserved'
      };

      results.push({
        medicationName: medication.name,
        success: true,
        reservationId: reservation.reservationId,
        quantity: reservation.quantity
      });

    } catch (error) {
      results.push({
        medicationName: medication.name,
        success: false,
        error: error.message
      });
    }
  }

  // Use session for save if provided
  await this.save(session ? { session } : {});

  return {
    success: results.every(r => r.success),
    results
  };
};

// Release all inventory reservations
// NOW WITH TRANSACTION SUPPORT
prescriptionSchema.methods.releaseInventoryReservations = async function(session = null) {
  if (this.type !== 'medication' || !this.medications || this.medications.length === 0) {
    return { success: true, message: 'No reservations to release' };
  }

  const PharmacyInventory = require('./PharmacyInventory');
  const results = [];

  for (const medication of this.medications) {
    if (!medication.reservation || medication.reservation.status !== 'reserved') {
      continue;
    }

    try {
      // Use session for transaction support
      const inventoryItem = await PharmacyInventory.findById(medication.inventoryItem).session(session);
      if (inventoryItem) {
        await inventoryItem.releaseReservation(medication.reservation.reservationId, session);
        medication.reservation.status = 'cancelled';
        results.push({
          medicationName: medication.name,
          success: true
        });
      }
    } catch (error) {
      results.push({
        medicationName: medication.name,
        success: false,
        error: error.message
      });
    }
  }

  // Use session for save if provided
  await this.save(session ? { session } : {});

  return {
    success: results.every(r => r.success),
    results
  };
};

// Fulfill reservation and dispense medication
// NOW WITH TRANSACTION SUPPORT
prescriptionSchema.methods.dispenseMedication = async function(medicationIndex, dispensedBy, pharmacyNotes, session = null) {
  if (this.type !== 'medication' || !this.medications[medicationIndex]) {
    throw new Error('Invalid medication index');
  }

  const medication = this.medications[medicationIndex];

  if (!medication.reservation || medication.reservation.status !== 'reserved') {
    throw new Error('No active reservation for this medication');
  }

  const PharmacyInventory = require('./PharmacyInventory');
  // Use session for transaction support
  const inventoryItem = await PharmacyInventory.findById(medication.inventoryItem).session(session);

  if (!inventoryItem) {
    throw new Error('Inventory item not found');
  }

  // Find the reservation in inventory
  const reservation = inventoryItem.reservations.find(
    r => r.reservationId === medication.reservation.reservationId && r.status === 'active'
  );

  if (!reservation) {
    throw new Error('Reservation not found in inventory');
  }

  // CRITICAL: Check for expired batches before dispensing
  const now = new Date();
  for (const reservedBatch of reservation.batches) {
    const batch = inventoryItem.batches.find(b => b.lotNumber === reservedBatch.lotNumber);
    if (batch && batch.expirationDate && new Date(batch.expirationDate) < now) {
      throw new Error(`Cannot dispense expired medication: Lot ${batch.lotNumber} expired on ${batch.expirationDate}`);
    }
  }

  // Deduct stock from batches
  for (const reservedBatch of reservation.batches) {
    const batch = inventoryItem.batches.find(b => b.lotNumber === reservedBatch.lotNumber);
    if (batch) {
      batch.quantity -= reservedBatch.quantity;
      batch.reserved = Math.max(0, (batch.reserved || 0) - reservedBatch.quantity);

      if (batch.quantity <= 0) {
        batch.status = 'depleted';
      }
    }
  }

  // Update inventory totals
  inventoryItem.inventory.currentStock -= reservation.quantity;
  inventoryItem.inventory.reserved = Math.max(0, inventoryItem.inventory.reserved - reservation.quantity);
  inventoryItem.inventory.dispensed = (inventoryItem.inventory.dispensed || 0) + reservation.quantity;

  // Mark reservation as fulfilled
  reservation.status = 'fulfilled';

  // Use session for save if provided
  await inventoryItem.save(session ? { session } : {});

  // Update prescription medication
  medication.reservation.status = 'fulfilled';
  medication.dispensing = {
    dispensed: true,
    dispensedQuantity: reservation.quantity,
    dispensedBatches: medication.reservation.reservedBatches,
    dispensedBy: dispensedBy,
    dispensedAt: new Date(),
    pharmacyNotes: pharmacyNotes
  };

  // Update prescription status
  const allDispensed = this.medications.every(m => m.dispensing?.dispensed);
  const someDispensed = this.medications.some(m => m.dispensing?.dispensed);

  if (allDispensed) {
    this.status = 'dispensed';
    this.pharmacyStatus = 'dispensed';
  } else if (someDispensed) {
    this.status = 'partial';
    this.pharmacyStatus = 'preparing';
  }

  // Use session for save if provided
  await this.save(session ? { session } : {});

  return {
    success: true,
    medication: medication.name,
    dispensedQuantity: reservation.quantity,
    batches: medication.reservation.reservedBatches
  };
};

module.exports = mongoose.model('Prescription', prescriptionSchema);