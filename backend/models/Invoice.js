const mongoose = require('mongoose');
const crypto = require('crypto');
const {
  validateAmount,
  validateExchangeRate,
  validatePayment,
  validateRefund,
  roundToDecimals,
  safeAdd,
  safeSubtract,
  safeMultiply,
  convertCurrency,
  CURRENCY_CONFIG
} = require('../utils/financialValidation');

const invoiceSchema = new mongoose.Schema({
  invoiceId: {
    type: String,
    unique: true,
    required: false  // Generated by pre-save hook
  },

  patient: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Patient',
    required: true,
    index: true
  },

  visit: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Visit',
    index: true
  },

  // Direct link to prescription (prevents race condition - only one invoice per prescription)
  prescription: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Prescription',
    sparse: true // Allows null values without unique constraint issues
  },

  // Direct link to lab order (auto-generated invoice)
  labOrder: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'LabOrder',
    sparse: true
  },

  // Direct link to IVT injection (auto-generated invoice)
  ivtInjection: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'IVTInjection',
    sparse: true
  },

  // Multi-Clinic: Which clinic issued this invoice
  clinic: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Clinic',
    index: true
  },

  dateIssued: {
    type: Date,
    default: Date.now,
    required: true
  },

  dueDate: {
    type: Date,
    required: true,
    default: () => new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // 30 days from now
  },

  // Invoice line items
  items: [{
    // Unique immutable ID for each item (prevents index fragility in payment allocations)
    itemId: {
      type: String,
      required: true,
      default: () => new mongoose.Types.ObjectId().toString(),
      immutable: true // Cannot be changed after creation
    },
    description: {
      type: String,
      required: true
    },
    category: {
      type: String,
      enum: ['consultation', 'procedure', 'medication', 'imaging', 'laboratory', 'therapy', 'device', 'surgery', 'examination', 'optical', 'other'],
      required: true
    },
    code: String, // CPT/billing code / Fee schedule code
    quantity: {
      type: Number,
      default: 1,
      min: 0
    },
    unitPrice: {
      type: Number,
      required: true,
      min: 0
    },
    discount: {
      type: Number,
      default: 0,
      min: 0
    },
    subtotal: {
      type: Number,
      required: true
    },
    tax: {
      type: Number,
      default: 0
    },
    total: {
      type: Number,
      required: true
    },
    reference: {
      type: String // Reference to prescription, exam, etc.
    },
    // Realization tracking - whether the billed act was actually performed
    realization: {
      realized: {
        type: Boolean,
        default: false
      },
      realizedAt: Date,
      realizedBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
      },
      notes: String
    },
    // Prescriber info for each act
    prescriber: {
      userId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
      },
      name: String,
      prescribedAt: Date
    },
    // Prior approval reference if required
    approval: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Approval'
    },
    approvalRequired: {
      type: Boolean,
      default: false
    },
    approvalStatus: {
      type: String,
      enum: ['not_required', 'pending', 'approved', 'rejected', 'missing', null]
    },
    // Convention coverage per item (for split billing display)
    coveragePercentage: {
      type: Number,
      min: 0,
      max: 100
    },
    companyShare: {
      type: Number,
      default: 0
    },
    patientShare: {
      type: Number,
      default: 0
    },
    notCovered: {
      type: Boolean,
      default: false
    },
    hasApproval: {
      type: Boolean,
      default: false
    },
    // Item-level payment tracking
    paidAmount: {
      type: Number,
      default: 0,
      min: 0
    },
    isPaid: {
      type: Boolean,
      default: false
    },
    // Track if surgery case was created for this item
    surgeryCaseCreated: {
      type: Boolean,
      default: false
    },
    surgeryCaseId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'SurgeryCase'
    },
    // Package deal fields - when item represents a bundled package
    isPackage: {
      type: Boolean,
      default: false
    },
    packageDetails: {
      packageId: mongoose.Schema.Types.ObjectId,
      packageCode: String,
      packageName: String,
      // Individual acts that were bundled into this package
      includedActs: [{
        code: String,
        description: String,
        originalPrice: Number
      }],
      // Financial tracking
      originalTotal: Number, // What it would have cost without package
      savings: Number,       // Amount saved by using package
      currency: {
        type: String,
        default: 'USD'
      }
    },

    // ============================================
    // EXTERNAL FULFILLMENT TRACKING
    // For services to be performed outside this clinic
    // ============================================
    fulfillment: {
      // Where this service will be performed
      location: {
        type: String,
        enum: ['internal', 'external'],
        default: 'internal'
      },

      // Reference to external facility (from ExternalFacility collection)
      externalFacility: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'ExternalFacility'
      },

      // Manual external provider info (if not in directory)
      externalProvider: {
        name: String,
        type: String, // 'pharmacy', 'laboratory', 'surgical-facility', etc.
        address: String,
        phone: String,
        email: String,
        contactPerson: String
      },

      // Dispatch status
      dispatchStatus: {
        type: String,
        enum: ['not_applicable', 'pending', 'dispatched', 'acknowledged', 'in_progress', 'completed', 'failed', 'cancelled'],
        default: 'not_applicable'
      },

      // Dispatch details
      dispatchedAt: Date,
      dispatchedBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
      },
      dispatchMethod: {
        type: String,
        enum: ['email', 'fax', 'api', 'print', 'sms', 'manual']
      },
      dispatchReference: String, // Tracking number or reference

      // Acknowledgment from external facility
      acknowledgedAt: Date,
      acknowledgedBy: String, // Name at external facility
      externalReference: String, // Their reference number
      estimatedCompletionDate: Date,

      // Completion tracking
      completedAt: Date,
      completedBy: String, // Name at external facility
      completionProof: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Document'
      },
      completionNotes: String,

      // Link to FulfillmentDispatch record for full audit trail
      fulfillmentDispatch: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'FulfillmentDispatch'
      },

      // Special instructions for external provider
      instructions: String
    },

    // Service completion tracking
    status: {
      type: String,
      enum: ['pending', 'completed', 'external'],
      default: 'pending'
    },
    completedAt: Date,
    completedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },

    // Per-item payment tracking
    paidTo: {
      type: String,
      enum: ['pharmacy', 'optical', 'clinic', null],
      default: null
    },
    paymentCollectedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    paymentCollectedAt: Date,

    // External tracking (patient getting service elsewhere)
    isExternal: {
      type: Boolean,
      default: false
    },
    markedExternalBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    markedExternalAt: Date,
    externalReason: String
  }],

  // Financial summary
  summary: {
    subtotal: {
      type: Number,
      required: true,
      default: 0
    },
    discountTotal: {
      type: Number,
      default: 0
    },
    taxTotal: {
      type: Number,
      default: 0
    },
    total: {
      type: Number,
      required: true,
      default: 0
    },
    // Convention billing: Company's share of the invoice
    companyShare: {
      type: Number,
      default: 0
    },
    // Convention billing: Patient's share of the invoice
    patientShare: {
      type: Number,
      default: 0
    },
    amountPaid: {
      type: Number,
      default: 0
    },
    amountDue: {
      type: Number,
      required: true
    }
  },

  // Payment information (supports multi-currency)
  payments: [{
    paymentId: {
      type: String,
      required: true
    },
    // Original payment amount in payment currency
    amount: {
      type: Number,
      required: true,
      min: 0
    },
    // Currency of the payment (CDF, USD, EUR)
    currency: {
      type: String,
      enum: ['CDF', 'USD', 'EUR'],
      default: 'CDF'
    },
    // Amount converted to base currency (CDF)
    amountInBaseCurrency: {
      type: Number,
      required: true,
      min: 0
    },
    // Exchange rate used at time of payment
    exchangeRate: {
      type: Number,
      default: 1
    },
    method: {
      type: String,
      enum: ['cash', 'card', 'check', 'bank-transfer', 'insurance', 'mobile-payment', 'orange-money', 'mtn-money', 'wave', 'other'],
      required: true
    },
    date: {
      type: Date,
      default: Date.now
    },
    reference: String, // Transaction reference number
    notes: String,
    receivedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
      // Optional: null for system-generated payments (webhooks, auto-payments)
    },
    isSystemGenerated: {
      type: Boolean,
      default: false
    },
    // Processing fees tracking
    processingFee: {
      amount: { type: Number, default: 0 },
      percentage: { type: Number, default: 0 },
      fixedFee: { type: Number, default: 0 },
      provider: String, // e.g., 'stripe', 'orange-money', 'mtn-money'
      netAmount: Number // amount - processingFee
    },
    // Transaction ID from payment provider
    transactionId: String,
    // Item-level payment allocation
    itemAllocations: [{
      // NEW: Use immutable itemId instead of index (prevents allocation errors when items reordered)
      itemId: {
        type: String,
        validate: {
          validator: function(itemId) {
            // Validate that itemId exists in invoice.items
            const invoice = this.parent().parent();
            return invoice.items.some(item => item.itemId === itemId);
          },
          message: 'Invalid itemId - item not found in invoice'
        }
      },
      // DEPRECATED: Kept for backward compatibility, will be migrated to itemId
      itemIndex: {
        type: Number
      },
      amount: {
        type: Number,
        required: true,
        min: 0
      }
    }]
  }],

  // Multi-currency payment breakdown
  currencyBreakdown: {
    CDF: { type: Number, default: 0 },
    USD: { type: Number, default: 0 },
    EUR: { type: Number, default: 0 }
  },

  // Invoice status
  status: {
    type: String,
    enum: ['draft', 'issued', 'sent', 'viewed', 'partial', 'paid', 'overdue', 'cancelled', 'refunded'],
    default: 'draft',
    index: true
  },

  // Invoice source (for workflow tracking)
  source: {
    type: String,
    enum: ['manual', 'visit', 'pharmacy', 'laboratory', 'optical', 'ivt', 'surgery', 'import'],
    default: 'manual',
    index: true
  },

  // Requires review before finalization (for auto-generated invoices)
  requiresReview: {
    type: Boolean,
    default: false
  },

  // Review tracking
  reviewedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  reviewedAt: Date,

  // Insurance information
  insurance: {
    used: {
      type: Boolean,
      default: false
    },
    provider: String,
    policyNumber: String,
    claimNumber: String,
    claimStatus: {
      type: String,
      enum: ['pending', 'submitted', 'approved', 'partially-approved', 'rejected', 'paid']
    },
    claimAmount: Number,
    approvedAmount: Number,
    patientResponsibility: Number,
    submittedDate: Date,
    approvedDate: Date
  },

  // Billing details
  billing: {
    billTo: {
      name: String,
      address: {
        street: String,
        city: String,
        state: String,
        postalCode: String,
        country: String
      },
      phone: String,
      email: String
    },
    currency: {
      type: String,
      enum: ['CDF', 'USD', 'EUR'],
      default: 'CDF' // Franc Congolais - devise de base
    },
    taxRate: {
      type: Number,
      default: 0
    }
  },

  // Company/Convention billing (for patients with employer/insurance coverage)
  companyBilling: {
    // Reference to the company (employer/insurance)
    company: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Company'
    },
    companyName: String, // Cached for display
    companyId: String, // Cached company code

    // Employee/Beneficiary info
    employeeId: String,
    beneficiaryType: {
      type: String,
      enum: ['employee', 'spouse', 'child', 'dependent']
    },

    // Coverage applied
    coveragePercentage: {
      type: Number,
      min: 0,
      max: 100,
      default: 100
    },

    // Financial split
    companyShare: {
      type: Number,
      default: 0
    },
    patientShare: {
      type: Number,
      default: 0
    },

    // Amounts in alternate currency (for dual display)
    companyShareUSD: Number,
    patientShareUSD: Number,
    totalUSD: Number,

    // Convention fee schedule used
    feeSchedule: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'ConventionFeeSchedule'
    },

    // Invoice to company status
    companyInvoiceStatus: {
      type: String,
      enum: ['pending', 'sent', 'acknowledged', 'disputed', 'paid', 'partial'],
      default: 'pending'
    },
    companyInvoiceSentAt: Date,
    companyInvoiceReference: String, // Company's internal reference

    // Payment from company
    companyPayment: {
      amount: Number,
      paidAt: Date,
      reference: String,
      notes: String
    },

    // Notes
    billingNotes: String,

    // Approval validation results (délibérations)
    baseCoveragePercentage: {
      type: Number,
      min: 0,
      max: 100
    },
    hasApprovalIssues: {
      type: Boolean,
      default: false
    },
    itemsNeedingApproval: {
      type: Number,
      default: 0
    }
  },

  // Track if this is a convention invoice (for quick filtering)
  isConventionInvoice: {
    type: Boolean,
    default: false,
    index: true
  },

  // Notes and communication
  notes: {
    internal: String, // Staff notes
    patient: String,  // Notes visible to patient
    billing: String   // Billing department notes
  },

  // Tracking
  sentDate: Date,
  viewedDate: Date,
  paidDate: Date,

  // Reminders
  reminders: [{
    sentDate: Date,
    method: {
      type: String,
      enum: ['email', 'sms', 'phone', 'mail']
    },
    sentBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    }
  }],

  // Cancellation/Refund
  cancellation: {
    cancelled: {
      type: Boolean,
      default: false
    },
    cancelledAt: Date,
    cancelledBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    reason: String
  },

  refund: {
    refunded: {
      type: Boolean,
      default: false
    },
    refundedAt: Date,
    refundedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    amount: Number,
    reason: String,
    method: String
  },

  // Discounts applied to this invoice
  discounts: [{
    amount: {
      type: Number,
      required: true
    },
    percentage: Number,
    reason: String,
    appliedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true
    },
    appliedAt: {
      type: Date,
      default: Date.now
    }
  }],

  // Write-offs applied to this invoice
  writeOffs: [{
    amount: {
      type: Number,
      required: true
    },
    reason: {
      type: String,
      required: true
    },
    writtenOffBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true
    },
    date: {
      type: Date,
      default: Date.now
    },
    approvedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    }
  }],

  // Insurance claim summary (synced from InsuranceClaim)
  insuranceSummary: {
    claimNumber: String,
    totalClaimed: { type: Number, default: 0 },
    approvedAmount: { type: Number, default: 0 },
    patientResponsibility: { type: Number, default: 0 },
    adjustments: { type: Number, default: 0 },
    paidAmount: { type: Number, default: 0 },
    status: {
      type: String,
      enum: ['pending', 'submitted', 'approved', 'partially-approved', 'rejected', 'paid', null]
    },
    denialReason: String,
    denialCode: String,
    paidAt: Date,
    checkNumber: String,
    eraNumber: String,
    lastUpdated: Date
  },

  // Insurance adjustment history
  insuranceAdjustments: [{
    claimId: { type: mongoose.Schema.Types.ObjectId, ref: 'InsuranceClaim' },
    claimNumber: String,
    providerName: String,
    status: String,
    totalClaimed: Number,
    approvedAmount: Number,
    paidAmount: Number,
    patientResponsibility: Number,
    adjustmentAmount: Number,
    writeOffAmount: Number,
    processedAt: { type: Date, default: Date.now },
    processedBy: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
    notes: String
  }],

  // Referrer Commission Tracking
  // IMMUTABLE COMMISSION: Store calculated amount at invoice creation time
  referrerCommission: {
    referrer: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Referrer'
    },
    referrerName: String, // Cached name for reports (refresh with refreshCachedNames)
    referrerType: { type: String, enum: ['internal', 'external'] },

    // IMMUTABLE: Calculated commission amount (fixed at invoice creation)
    commissionAmount: {
      type: Number,
      default: 0,
      required: true
    },

    // Calculation audit trail (for transparency and verification)
    calculatedAt: {
      type: Date,
      default: Date.now
    },
    calculationBasis: {
      type: { type: String, enum: ['percentage', 'fixed', 'per_act'] },
      rate: Number,        // What rate was used (for audit trail)
      baseAmount: Number   // What amount it was calculated on
    },

    // Payment status tracking
    status: {
      type: String,
      enum: ['pending', 'approved', 'paid', 'cancelled'],
      default: 'pending'
    },
    paidAt: Date,
    paidBy: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
    paymentReference: String,
    notes: String

    // REMOVED FIELDS (now stored in calculationBasis for audit only):
    // - commissionType: moved to calculationBasis.type
    // - commissionRate: moved to calculationBasis.rate
    // - baseAmount: moved to calculationBasis.baseAmount
  },

  // ============================================
  // EXTERNAL FULFILLMENT SUMMARY
  // Overall status of external services on this invoice
  // ============================================
  externalFulfillment: {
    // Does this invoice have any external items?
    hasExternalItems: {
      type: Boolean,
      default: false
    },

    // Summary counts
    totalExternalItems: { type: Number, default: 0 },
    pendingDispatch: { type: Number, default: 0 },
    dispatchedCount: { type: Number, default: 0 },
    completedCount: { type: Number, default: 0 },

    // Overall status
    overallStatus: {
      type: String,
      enum: ['none', 'pending', 'partial', 'all_dispatched', 'all_completed'],
      default: 'none'
    },

    // Last dispatch action
    lastDispatchedAt: Date,
    lastDispatchedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },

    // All external facility references for this invoice
    facilities: [{
      facility: { type: mongoose.Schema.Types.ObjectId, ref: 'ExternalFacility' },
      facilityName: String,
      itemCount: Number,
      dispatchedCount: Number,
      completedCount: Number
    }],

    // Notes about external fulfillment
    notes: String
  },

  // Edit history tracking
  editHistory: [{
    editedAt: {
      type: Date,
      default: Date.now
    },
    editedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    action: {
      type: String,
      enum: ['create', 'update', 'status_change', 'payment_added', 'payment_refund', 'discount_applied', 'write_off', 'cancelled', 'insurance_adjustment'],
      required: true
    },
    changes: {
      type: mongoose.Schema.Types.Mixed,
      default: {}
    },
    previousValues: {
      type: mongoose.Schema.Types.Mixed,
      default: {}
    },
    notes: String
  }],

  // Audit trail
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  updatedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },

  // Version control for optimistic locking
  version: {
    type: Number,
    default: 0
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Indexes for efficient queries
invoiceSchema.index({ invoiceId: 1 }, { unique: true });
invoiceSchema.index({ patient: 1, dateIssued: -1 });
invoiceSchema.index({ status: 1, dueDate: 1 });
invoiceSchema.index({ 'insurance.claimStatus': 1 });
invoiceSchema.index({ createdAt: -1 });
// CRITICAL: Unique sparse index prevents race condition - only one invoice per prescription
invoiceSchema.index({ prescription: 1 }, { unique: true, sparse: true });

// Performance indexes for billing reports
invoiceSchema.index({ status: 1, dateIssued: -1 }); // Invoice aging reports
invoiceSchema.index({ status: 1, 'summary.amountDue': 1 }); // Outstanding balance queries
invoiceSchema.index({ 'insurance.claimStatus': 1, createdAt: -1 }); // Claim tracking
invoiceSchema.index({ visit: 1 }); // Visit-to-invoice lookups

// Company/Convention billing indexes
invoiceSchema.index({ 'companyBilling.company': 1, dateIssued: -1 }); // Company invoice reports
invoiceSchema.index({ 'companyBilling.company': 1, 'companyBilling.companyInvoiceStatus': 1 }); // Company payment tracking
invoiceSchema.index({ isConventionInvoice: 1, dateIssued: -1 }); // Convention invoice filtering
invoiceSchema.index({ 'items.realization.realized': 1 }); // Realization tracking

// CRITICAL: Multi-clinic indexes for data isolation and performance
invoiceSchema.index({ clinic: 1, dateIssued: -1 }); // Clinic-scoped invoice list
invoiceSchema.index({ clinic: 1, status: 1 }); // Clinic-scoped status filtering
invoiceSchema.index({ clinic: 1, patient: 1 }); // Clinic-scoped patient invoices
invoiceSchema.index({ clinic: 1, 'summary.amountDue': 1 }); // Clinic-scoped outstanding balance

// Additional compound indexes for common query patterns
invoiceSchema.index({ 'companyBilling.company': 1, status: 1, createdAt: -1 }); // Company invoices by status
invoiceSchema.index({ patient: 1, createdAt: -1 }); // Patient invoice history by creation date
invoiceSchema.index({ clinic: 1, status: 1, createdAt: -1 }); // Clinic invoices by status and date
invoiceSchema.index({ 'payments.date': -1 }); // Payment date queries for financial reports

// Virtual for days overdue
invoiceSchema.virtual('daysOverdue').get(function() {
  if (this.status !== 'overdue') return 0;
  const today = new Date();
  const due = new Date(this.dueDate);
  const diffTime = today - due;
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  return diffDays > 0 ? diffDays : 0;
});

// Virtual for is overdue
invoiceSchema.virtual('isOverdue').get(function() {
  if (['paid', 'cancelled', 'refunded'].includes(this.status)) return false;
  return new Date() > new Date(this.dueDate) && this.summary.amountDue > 0;
});

// Pre-save hook to generate invoice ID
invoiceSchema.pre('save', async function(next) {
  if (!this.invoiceId) {
    const Counter = require('./Counter');
    const year = new Date().getFullYear();
    const month = String(new Date().getMonth() + 1).padStart(2, '0');
    const invCounterId = `invoice-${year}${month}`;
    const sequence = await Counter.getNextSequence(invCounterId);
    this.invoiceId = `INV${year}${month}${String(sequence).padStart(6, '0')}`;
  }

  // Set due date if not provided (default 30 days)
  if (!this.dueDate) {
    this.dueDate = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);
  }

  // Calculate summary totals using safe arithmetic to avoid floating-point errors
  if (this.items && this.items.length > 0) {
    this.summary.subtotal = roundToDecimals(
      this.items.reduce((sum, item) => sum + (parseFloat(item.subtotal) || 0), 0),
      0 // CDF has no decimals
    );
    this.summary.discountTotal = roundToDecimals(
      this.items.reduce((sum, item) => sum + (parseFloat(item.discount) || 0), 0),
      0
    );
    this.summary.taxTotal = roundToDecimals(
      this.items.reduce((sum, item) => sum + (parseFloat(item.tax) || 0), 0),
      0
    );
    this.summary.total = roundToDecimals(
      this.items.reduce((sum, item) => sum + (parseFloat(item.total) || 0), 0),
      0
    );
  }

  // Calculate amount paid (use amountInBaseCurrency for multi-currency support)
  if (this.payments && this.payments.length > 0) {
    this.summary.amountPaid = roundToDecimals(
      this.payments.reduce((sum, payment) => {
        // Use amountInBaseCurrency if available (for multi-currency), otherwise use amount
        const paymentAmount = parseFloat(payment.amountInBaseCurrency) || parseFloat(payment.amount) || 0;
        return sum + paymentAmount;
      }, 0),
      0 // CDF has no decimals
    );
  }

  // Calculate amount due using safe subtraction to prevent negative due to floating-point errors
  // CRITICAL FIX: For convention invoices, patient only owes their share (patientShare), not the full total
  // The companyShare is billed separately to the company
  if (this.isConventionInvoice && this.companyBilling?.patientShare !== undefined) {
    // For convention invoices: amountDue = patientShare - amountPaid
    // Patient is only responsible for their portion (after company coverage)
    this.summary.amountDue = Math.max(0, safeSubtract(this.companyBilling.patientShare, this.summary.amountPaid));
  } else {
    // For regular invoices: amountDue = total - amountPaid
    this.summary.amountDue = Math.max(0, safeSubtract(this.summary.total, this.summary.amountPaid));
  }

  // Auto-update status based on payment
  if (this.summary.amountDue <= 0 && this.summary.total > 0) {
    this.status = 'paid';
    if (!this.paidDate) {
      this.paidDate = new Date();
    }
  } else if (this.summary.amountPaid > 0 && this.summary.amountDue > 0) {
    this.status = 'partial';
  } else if (this.isOverdue && this.status !== 'cancelled') {
    this.status = 'overdue';
  }

  next();
});

// Method to add payment (supports multi-currency)
// Options: { allowOverpayment: boolean, createCredit: boolean, skipDuplicateCheck: boolean, expectedVersion: number }
invoiceSchema.methods.addPayment = async function(paymentData, userId, session = null, options = {}) {
  // Optimistic locking: check version if provided
  if (options.expectedVersion !== undefined && this.version !== options.expectedVersion) {
    throw new Error(`Concurrent modification detected. Invoice was modified by another user. Expected version ${options.expectedVersion}, current version ${this.version}. Please refresh and try again.`);
  }

  // Validate payment data using financial validation utilities
  const paymentValidation = validatePayment({
    amount: paymentData.amount,
    currency: paymentData.currency || 'CDF',
    exchangeRate: paymentData.exchangeRate,
    method: paymentData.method,
    date: paymentData.date
  });

  if (!paymentValidation.valid) {
    throw new Error(`Payment validation failed: ${paymentValidation.errors.join(', ')}`);
  }

  // Validate exchange rate if not base currency
  const currency = paymentData.currency || 'CDF';
  if (currency !== 'CDF' && paymentData.exchangeRate) {
    const rateValidation = validateExchangeRate(paymentData.exchangeRate, currency, 'CDF');
    if (!rateValidation.valid) {
      throw new Error(`Exchange rate validation failed: ${rateValidation.error}`);
    }
    if (rateValidation.warning) {
      console.warn(`Payment exchange rate warning: ${rateValidation.warning}`);
    }
  }

  // Check for duplicate payment by transactionId or reference
  if (!options.skipDuplicateCheck) {
    if (paymentData.transactionId) {
      const existingByTxn = this.payments.find(p => p.transactionId === paymentData.transactionId);
      if (existingByTxn) {
        throw new Error(`Duplicate payment: Transaction ID ${paymentData.transactionId} already recorded`);
      }
    }

    // Check for duplicate by reference (if provided and looks like a unique ID)
    if (paymentData.reference && paymentData.reference.length > 5) {
      const existingByRef = this.payments.find(p =>
        p.reference === paymentData.reference &&
        p.method === paymentData.method &&
        Math.abs(p.amount - paymentData.amount) < 0.01
      );
      if (existingByRef) {
        throw new Error(`Duplicate payment: Reference ${paymentData.reference} already recorded with same amount`);
      }
    }

    // Check for exact duplicate (same amount, method, within 1 minute)
    const oneMinuteAgo = new Date(Date.now() - 60000);
    const recentDuplicate = this.payments.find(p =>
      Math.abs(p.amount - paymentData.amount) < 0.01 &&
      p.method === paymentData.method &&
      p.currency === currency &&
      new Date(p.date) > oneMinuteAgo
    );
    if (recentDuplicate) {
      throw new Error(`Potential duplicate payment: Same amount (${paymentData.amount}) and method (${paymentData.method}) recorded within the last minute`);
    }
  }

  const paymentId = `PAY${Date.now()}${crypto.randomBytes(6).toString('hex').toUpperCase()}`;

  // Use safe arithmetic for currency conversion
  const amount = paymentValidation.sanitized.amount;
  const exchangeRate = paymentData.exchangeRate || 1;

  // Calculate amount in base currency with proper rounding
  let amountInBaseCurrency;
  if (paymentData.amountInBaseCurrency) {
    // Validate provided base currency amount
    const baseAmountValidation = validateAmount(paymentData.amountInBaseCurrency, {
      currency: 'CDF',
      fieldName: 'Amount in base currency'
    });
    if (!baseAmountValidation.valid) {
      throw new Error(baseAmountValidation.error);
    }
    amountInBaseCurrency = baseAmountValidation.sanitized;
  } else if (currency === 'CDF') {
    amountInBaseCurrency = amount;
  } else {
    // Convert with safe multiplication
    const conversion = convertCurrency(amount, exchangeRate, currency, 'CDF');
    if (!conversion.success) {
      throw new Error(`Currency conversion failed: ${conversion.error}`);
    }
    amountInBaseCurrency = conversion.amount;
  }

  // Check for overpayment using safe arithmetic
  const overpayment = roundToDecimals(amountInBaseCurrency - this.summary.amountDue, 0); // CDF has no decimals
  if (overpayment > 0 && !options.allowOverpayment) {
    throw new Error(`Payment amount (${amountInBaseCurrency} CDF) exceeds amount due (${this.summary.amountDue} CDF)`);
  }

  // Calculate processing fees if applicable
  let processingFee = null;
  if (paymentData.processingFee) {
    const feeAmount = paymentData.processingFee.amount ||
      safeMultiply(amount, paymentData.processingFee.percentage || 0, 2) / 100 +
      (paymentData.processingFee.fixedFee || 0);

    processingFee = {
      amount: roundToDecimals(feeAmount, CURRENCY_CONFIG[currency]?.decimals ?? 2),
      percentage: paymentData.processingFee.percentage || 0,
      fixedFee: paymentData.processingFee.fixedFee || 0,
      provider: paymentData.processingFee.provider,
      netAmount: roundToDecimals(amount - feeAmount, CURRENCY_CONFIG[currency]?.decimals ?? 2)
    };
  }

  // Build item allocations - either from input or auto-allocate (FIFO)
  let itemAllocations = [];
  let remainingToAllocate = amountInBaseCurrency;

  if (paymentData.itemAllocations && paymentData.itemAllocations.length > 0) {
    // Use provided allocations
    itemAllocations = paymentData.itemAllocations.map(alloc => ({
      itemIndex: alloc.itemIndex,
      amount: alloc.amount
    }));
  } else {
    // Auto-allocate in FIFO order (first items first)
    for (let i = 0; i < this.items.length && remainingToAllocate > 0; i++) {
      const item = this.items[i];
      const itemDue = (item.total || 0) - (item.paidAmount || 0);

      if (itemDue > 0) {
        const allocationAmount = Math.min(itemDue, remainingToAllocate);
        itemAllocations.push({
          itemIndex: i,
          amount: allocationAmount
        });
        remainingToAllocate -= allocationAmount;
      }
    }
  }

  const payment = {
    paymentId,
    amount,
    currency,
    amountInBaseCurrency,
    exchangeRate,
    method: paymentData.method,
    transactionId: paymentData.transactionId,
    date: paymentData.date || new Date(),
    reference: paymentData.reference,
    notes: paymentData.notes,
    receivedBy: userId,
    isSystemGenerated: paymentData.isSystemGenerated || false,
    processingFee,
    itemAllocations
  };

  // Store previous values for audit
  const previousAmountPaid = this.summary.amountPaid;
  const previousAmountDue = this.summary.amountDue;
  const previousStatus = this.status;

  this.payments.push(payment);

  // Update item-level paid amounts
  const newlyPaidItems = [];
  for (const alloc of itemAllocations) {
    if (alloc.itemIndex >= 0 && alloc.itemIndex < this.items.length) {
      const item = this.items[alloc.itemIndex];
      item.paidAmount = (item.paidAmount || 0) + alloc.amount;

      // Check if item is now fully paid
      const wasFullyPaid = item.isPaid;
      item.isPaid = item.paidAmount >= (item.total || 0);

      // Track newly paid items
      if (item.isPaid && !wasFullyPaid) {
        newlyPaidItems.push({
          itemIndex: alloc.itemIndex,
          item: item
        });
      }
    }
  }

  // Update currency breakdown using safe arithmetic
  if (!this.currencyBreakdown) {
    this.currencyBreakdown = { CDF: 0, USD: 0, EUR: 0 };
  }
  this.currencyBreakdown[currency] = safeAdd(this.currencyBreakdown[currency] || 0, amount);

  // Record edit history for audit
  this.recordEdit('payment_added', {
    paymentId,
    amount,
    currency,
    amountInBaseCurrency,
    method: paymentData.method
  }, {
    amountPaid: previousAmountPaid,
    amountDue: previousAmountDue,
    status: previousStatus
  }, userId, `Payment of ${amount} ${currency} received`);

  this.updatedBy = userId;

  await this.save(session ? { session } : {});

  // Handle overpayment by adding credit to patient account
  let creditResult = null;
  if (overpayment > 0 && options.createCredit && this.patient) {
    try {
      const Patient = mongoose.model('Patient');
      creditResult = await Patient.addCredit(
        this.patient,
        overpayment,
        `Overpayment on invoice ${this.invoiceId}`,
        userId
      );
    } catch (err) {
      console.error('Failed to create patient credit for overpayment:', err.message);
    }
  }

  return { payment, overpayment: overpayment > 0 ? overpayment : 0, creditResult, newlyPaidItems };
};

// Method to add multiple payments in different currencies (split payment)
invoiceSchema.methods.addMultiCurrencyPayment = async function(payments, userId, session = null) {
  const addedPayments = [];

  for (const paymentData of payments) {
    const paymentId = `PAY${Date.now()}${crypto.randomBytes(4).toString('hex').toUpperCase()}`;

    const currency = paymentData.currency || 'CDF';
    const amount = paymentData.amount;
    const exchangeRate = paymentData.exchangeRate || 1;
    const amountInBaseCurrency = paymentData.amountInBaseCurrency || (currency === 'CDF' ? amount : amount * exchangeRate);

    const payment = {
      paymentId,
      amount,
      currency,
      amountInBaseCurrency,
      exchangeRate,
      method: paymentData.method,
      date: paymentData.date || new Date(),
      reference: paymentData.reference,
      notes: `Multi-currency payment: ${amount} ${currency}`,
      receivedBy: userId
    };

    this.payments.push(payment);
    addedPayments.push(payment);

    // Update currency breakdown
    if (!this.currencyBreakdown) {
      this.currencyBreakdown = { CDF: 0, USD: 0, EUR: 0 };
    }
    this.currencyBreakdown[currency] = (this.currencyBreakdown[currency] || 0) + amount;
  }

  this.updatedBy = userId;
  await this.save(session ? { session } : {});

  return addedPayments;
};

// Method to cancel invoice
invoiceSchema.methods.cancel = async function(userId, reason, session = null) {
  if (this.summary.amountPaid > 0) {
    throw new Error('Cannot cancel invoice with payments. Please refund first.');
  }

  this.status = 'cancelled';
  this.cancellation = {
    cancelled: true,
    cancelledAt: new Date(),
    cancelledBy: userId,
    reason
  };
  this.updatedBy = userId;

  await this.save(session ? { session } : {});
};

// Method to recalculate invoice totals from items (for category-based payment system)
invoiceSchema.methods.recalculateTotals = function() {
  // Calculate totals from items
  let subtotal = 0;
  let discountTotal = 0;
  let taxTotal = 0;
  let total = 0;
  let amountPaid = 0;
  let externalTotal = 0;

  for (const item of this.items) {
    subtotal += item.subtotal || 0;
    discountTotal += item.discount || 0;
    taxTotal += item.tax || 0;
    total += item.total || 0;
    amountPaid += item.paidAmount || 0;

    // External items don't count towards amount due
    if (item.isExternal) {
      externalTotal += item.total || 0;
    }
  }

  // Amount due = total - external items - amount paid
  const amountDue = total - externalTotal - amountPaid;

  this.summary = {
    ...this.summary,
    subtotal,
    discountTotal,
    taxTotal,
    total,
    amountPaid,
    amountDue: Math.max(0, amountDue),
    externalTotal
  };

  // Update invoice status based on payments
  if (amountPaid <= 0) {
    if (this.status !== 'cancelled' && this.status !== 'refunded') {
      this.status = 'issued';
    }
  } else if (amountPaid >= (total - externalTotal)) {
    this.status = 'paid';
  } else {
    this.status = 'partial';
  }
};

// Method to issue refund (supports multi-currency)
// Options: { currency, exchangeRate, expectedVersion, originalPaymentId }
invoiceSchema.methods.issueRefund = async function(amount, userId, reason, method, session = null, options = {}) {
  // Optimistic locking
  if (options.expectedVersion !== undefined && this.version !== options.expectedVersion) {
    throw new Error(`Concurrent modification detected. Invoice was modified. Expected version ${options.expectedVersion}, current version ${this.version}.`);
  }

  // Validate refund using financial validation
  const refundValidation = validateRefund({ amount, reason }, this);
  if (!refundValidation.valid) {
    throw new Error(`Refund validation failed: ${refundValidation.errors.join(', ')}`);
  }

  // Determine refund currency
  const refundCurrency = options.currency || this.billing?.currency || 'CDF';
  const exchangeRate = options.exchangeRate || 1;

  // Calculate refund in base currency
  let amountInBaseCurrency;
  if (refundCurrency === 'CDF') {
    amountInBaseCurrency = refundValidation.sanitizedAmount;
  } else {
    // Validate exchange rate
    const rateValidation = validateExchangeRate(exchangeRate, refundCurrency, 'CDF');
    if (!rateValidation.valid) {
      throw new Error(`Exchange rate validation failed: ${rateValidation.error}`);
    }
    amountInBaseCurrency = roundToDecimals(refundValidation.sanitizedAmount * exchangeRate, 0);
  }

  // Validate refund doesn't exceed amount paid
  if (amountInBaseCurrency > this.summary.amountPaid) {
    throw new Error(`Refund amount (${amountInBaseCurrency} CDF) exceeds amount paid (${this.summary.amountPaid} CDF)`);
  }

  // If refunding a specific payment, validate it exists
  let originalPayment = null;
  if (options.originalPaymentId) {
    originalPayment = this.payments.find(p => p.paymentId === options.originalPaymentId);
    if (!originalPayment) {
      throw new Error(`Original payment ${options.originalPaymentId} not found`);
    }
    // For multi-currency: refund should ideally be in same currency as original payment
    if (originalPayment.currency !== refundCurrency) {
      console.warn(`Refund currency (${refundCurrency}) differs from original payment currency (${originalPayment.currency})`);
    }
  }

  // Store previous values for audit
  const previousAmountPaid = this.summary.amountPaid;
  const previousAmountDue = this.summary.amountDue;
  const previousStatus = this.status;

  this.refund = {
    refunded: true,
    refundedAt: new Date(),
    refundedBy: userId,
    amount: refundValidation.sanitizedAmount,
    reason,
    method,
    currency: refundCurrency,
    exchangeRate,
    amountInBaseCurrency,
    originalPaymentId: options.originalPaymentId
  };

  // Create negative payment record for audit trail
  const refundPaymentId = `REF${Date.now()}${crypto.randomBytes(4).toString('hex').toUpperCase()}`;
  this.payments.push({
    paymentId: refundPaymentId,
    amount: -refundValidation.sanitizedAmount,  // Negative for refund
    currency: refundCurrency,
    amountInBaseCurrency: -amountInBaseCurrency,
    exchangeRate,
    method: method || 'refund',
    date: new Date(),
    reference: `Refund: ${reason}${options.originalPaymentId ? ` (Original: ${options.originalPaymentId})` : ''}`,
    notes: reason,
    receivedBy: userId
  });

  // Update summary using safe arithmetic
  this.summary.amountPaid = safeSubtract(this.summary.amountPaid, amountInBaseCurrency);
  this.summary.amountDue = safeAdd(this.summary.amountDue, amountInBaseCurrency);

  // Update currency breakdown
  if (this.currencyBreakdown && this.currencyBreakdown[refundCurrency]) {
    this.currencyBreakdown[refundCurrency] = safeSubtract(
      this.currencyBreakdown[refundCurrency],
      refundValidation.sanitizedAmount
    );
  }

  // Determine new status
  if (this.summary.amountDue >= this.summary.total) {
    this.status = 'refunded';
  } else if (this.summary.amountPaid > 0) {
    this.status = 'partial';
  } else {
    this.status = 'issued';
  }

  // Record edit history for audit
  this.recordEdit('payment_refund', {
    refundPaymentId,
    amount: refundValidation.sanitizedAmount,
    currency: refundCurrency,
    amountInBaseCurrency,
    reason,
    method,
    originalPaymentId: options.originalPaymentId
  }, {
    amountPaid: previousAmountPaid,
    amountDue: previousAmountDue,
    status: previousStatus
  }, userId, `Refund of ${refundValidation.sanitizedAmount} ${refundCurrency}: ${reason}`);

  this.updatedBy = userId;

  await this.save(session ? { session } : {});

  return {
    refundId: refundPaymentId,
    amount: refundValidation.sanitizedAmount,
    currency: refundCurrency,
    amountInBaseCurrency,
    newAmountDue: this.summary.amountDue,
    newStatus: this.status
  };
};

// Method to send reminder
invoiceSchema.methods.sendReminder = async function(method, userId, session = null) {
  this.reminders.push({
    sentDate: new Date(),
    method,
    sentBy: userId
  });

  await this.save(session ? { session } : {});
};

// Method to record edit in history
invoiceSchema.methods.recordEdit = function(action, changes, previousValues, userId, notes = null) {
  if (!this.editHistory) {
    this.editHistory = [];
  }

  this.editHistory.push({
    editedAt: new Date(),
    editedBy: userId,
    action,
    changes,
    previousValues,
    notes
  });

  // Increment version
  this.version = (this.version || 0) + 1;
};

// Method to get edit history
invoiceSchema.methods.getEditHistory = async function() {
  await this.populate('editHistory.editedBy', 'firstName lastName email');
  return this.editHistory.sort((a, b) => b.editedAt - a.editedAt);
};

/**
 * Method to refresh cached names from source documents
 * CRITICAL: Cached names (company, referrer, facility) can become stale
 * Use this method to update them from authoritative sources
 */
invoiceSchema.methods.refreshCachedNames = async function() {
  const updates = {};

  // Refresh company billing cached name
  if (this.companyBilling?.company) {
    try {
      const Company = mongoose.model('Company');
      const company = await Company.findById(this.companyBilling.company).select('name companyId');
      if (company) {
        updates['companyBilling.companyName'] = company.name;
        updates['companyBilling.companyId'] = company.companyId;
      }
    } catch (err) {
      console.error('[INVOICE] Error refreshing company name:', err.message);
    }
  }

  // Refresh referrer commission cached name
  if (this.referrerCommission?.referrer) {
    try {
      const Referrer = mongoose.model('Referrer');
      const referrer = await Referrer.findById(this.referrerCommission.referrer).select('name type');
      if (referrer) {
        updates['referrerCommission.referrerName'] = referrer.name;
        updates['referrerCommission.referrerType'] = referrer.type;
      }
    } catch (err) {
      console.error('[INVOICE] Error refreshing referrer name:', err.message);
    }
  }

  // Refresh external facility cached names in externalFulfillment.facilities
  if (this.externalFulfillment?.facilities && this.externalFulfillment.facilities.length > 0) {
    try {
      const ExternalFacility = mongoose.model('ExternalFacility');
      for (let i = 0; i < this.externalFulfillment.facilities.length; i++) {
        const facilityRef = this.externalFulfillment.facilities[i];
        if (facilityRef.facility) {
          const facility = await ExternalFacility.findById(facilityRef.facility).select('name');
          if (facility) {
            updates[`externalFulfillment.facilities.${i}.facilityName`] = facility.name;
          }
        }
      }
    } catch (err) {
      console.error('[INVOICE] Error refreshing facility names:', err.message);
    }
  }

  // Apply updates if any
  if (Object.keys(updates).length > 0) {
    await this.updateOne({ $set: updates });
    console.log(`[INVOICE] Refreshed ${Object.keys(updates).length} cached name(s) for invoice ${this.invoiceId || this._id}`);
  }

  return updates;
};

// Static method to get YTD company billing usage by category for a patient
invoiceSchema.statics.getPatientYTDCategoryUsage = async function(patientId, companyId, year = new Date().getFullYear()) {
  const startOfYear = new Date(year, 0, 1);
  const endOfYear = new Date(year, 11, 31, 23, 59, 59);

  const result = await this.aggregate([
    {
      $match: {
        patient: new mongoose.Types.ObjectId(patientId),
        'companyBilling.company': new mongoose.Types.ObjectId(companyId),
        isConventionInvoice: true,
        status: { $nin: ['cancelled', 'voided', 'refunded'] },
        dateIssued: { $gte: startOfYear, $lte: endOfYear }
      }
    },
    { $unwind: '$items' },
    {
      $group: {
        _id: '$items.category',
        totalCompanyShare: { $sum: { $ifNull: ['$items.companyShare', 0] } },
        totalPatientShare: { $sum: { $ifNull: ['$items.patientShare', 0] } },
        totalAmount: { $sum: { $multiply: [{ $ifNull: ['$items.quantity', 1] }, { $ifNull: ['$items.unitPrice', 0] }] } },
        itemCount: { $sum: 1 }
      }
    }
  ]);

  // Convert to map for easy lookup
  const usageByCategory = {};
  for (const cat of result) {
    usageByCategory[cat._id || 'other'] = {
      totalCompanyShare: cat.totalCompanyShare,
      totalPatientShare: cat.totalPatientShare,
      totalAmount: cat.totalAmount,
      itemCount: cat.itemCount
    };
  }

  return usageByCategory;
};

// Static method to get unrealized items for a company
invoiceSchema.statics.getUnrealizedItemsForCompany = async function(companyId, options = {}) {
  const { dateFrom, dateTo, limit = 100, skip = 0 } = options;

  const dateMatch = {};
  if (dateFrom) dateMatch.$gte = new Date(dateFrom);
  if (dateTo) dateMatch.$lte = new Date(dateTo);

  const matchStage = {
    'companyBilling.company': new mongoose.Types.ObjectId(companyId),
    isConventionInvoice: true,
    status: { $nin: ['cancelled', 'voided'] }
  };

  if (Object.keys(dateMatch).length > 0) {
    matchStage.dateIssued = dateMatch;
  }

  const result = await this.aggregate([
    { $match: matchStage },
    { $unwind: { path: '$items', includeArrayIndex: 'itemIndex' } },
    {
      $match: {
        $or: [
          { 'items.realization.realized': { $ne: true } },
          { 'items.realization': { $exists: false } }
        ]
      }
    },
    {
      $lookup: {
        from: 'patients',
        localField: 'patient',
        foreignField: '_id',
        as: 'patientInfo'
      }
    },
    { $unwind: '$patientInfo' },
    {
      $project: {
        invoiceId: 1,
        dateIssued: 1,
        itemIndex: 1,
        item: '$items',
        patient: {
          _id: '$patientInfo._id',
          patientId: '$patientInfo.patientId',
          firstName: '$patientInfo.firstName',
          lastName: '$patientInfo.lastName',
          employeeId: '$patientInfo.convention.employeeId'
        },
        companyShare: '$items.companyShare'
      }
    },
    { $sort: { dateIssued: -1 } },
    { $skip: skip },
    { $limit: limit }
  ]);

  // Get total count
  const countResult = await this.aggregate([
    { $match: matchStage },
    { $unwind: '$items' },
    {
      $match: {
        $or: [
          { 'items.realization.realized': { $ne: true } },
          { 'items.realization': { $exists: false } }
        ]
      }
    },
    { $count: 'total' }
  ]);

  return {
    items: result,
    total: countResult[0]?.total || 0,
    totalCompanyShare: result.reduce((sum, r) => sum + (r.companyShare || 0), 0)
  };
};

// Method to apply company billing (convention) with approval validation
invoiceSchema.methods.applyCompanyBilling = async function(companyId, userId, exchangeRateUSD = null, options = {}) {
  const Company = mongoose.model('Company');
  const ConventionFeeSchedule = mongoose.model('ConventionFeeSchedule');
  const Patient = mongoose.model('Patient');
  const Approval = mongoose.model('Approval');

  const company = await Company.findById(companyId);
  if (!company) {
    throw new Error('Entreprise non trouvée');
  }

  // Check contract status
  if (company.contract?.status !== 'active') {
    throw new Error(`Contrat de l'entreprise ${company.name} n'est pas actif (${company.contract?.status})`);
  }

  // Check contract expiry
  if (company.contract?.endDate && new Date(company.contract.endDate) < new Date()) {
    throw new Error(`Contrat de l'entreprise ${company.name} a expiré`);
  }

  // Get patient for employee info
  const patient = await Patient.findById(this.patient);
  if (!patient) {
    throw new Error('Patient non trouvé');
  }

  // ========================================
  // WAITING PERIOD CHECK
  // ========================================
  const waitingPeriodDays = company.defaultCoverage?.waitingPeriod || 0;
  let waitingPeriodWarning = null;

  if (waitingPeriodDays > 0 && patient.convention?.startDate) {
    const startDate = new Date(patient.convention.startDate);
    const waitingEndDate = new Date(startDate);
    waitingEndDate.setDate(waitingEndDate.getDate() + waitingPeriodDays);

    if (new Date() < waitingEndDate) {
      const daysRemaining = Math.ceil((waitingEndDate - new Date()) / (1000 * 60 * 60 * 24));
      waitingPeriodWarning = `Période d'attente en cours: ${daysRemaining} jour(s) restant(s). Le patient sera responsable à 100%.`;

      if (!options.bypassWaitingPeriod) {
        // If waiting period not bypassed, patient pays 100%
        // But we still proceed with billing to track properly
      }
    }
  }

  // Get effective fee schedule for company (with parent fallback)
  const feeSchedule = await ConventionFeeSchedule.getEffectiveForCompany(companyId);

  // ========================================
  // YTD CATEGORY USAGE FOR ANNUAL LIMITS
  // ========================================
  // Use CompanyUsage cache for fast lookups, fallback to aggregation if cache not populated
  const Invoice = mongoose.model('Invoice');
  let ytdUsage;

  try {
    const CompanyUsage = mongoose.model('CompanyUsage');
    const usage = await CompanyUsage.findOne({
      patient: this.patient,
      company: companyId,
      fiscalYear: new Date().getFullYear()
    });

    if (usage) {
      // Use cached usage (fast path - O(1) lookup)
      ytdUsage = usage.getCategoryUsageMap();
    } else {
      // Fallback to aggregation (slow path - O(n) where n = invoice count)
      ytdUsage = await Invoice.getPatientYTDCategoryUsage(
        this.patient,
        companyId,
        new Date().getFullYear()
      );
    }
  } catch (usageErr) {
    // If CompanyUsage model not available, fallback to aggregation
    console.warn('[Invoice] CompanyUsage lookup failed, using aggregation fallback:', usageErr.message);
    ytdUsage = await Invoice.getPatientYTDCategoryUsage(
      this.patient,
      companyId,
      new Date().getFullYear()
    );
  }
  const annualLimitWarnings = [];

  // Determine base coverage percentage
  let baseCoveragePercentage = company.defaultCoverage.percentage;
  if (patient.convention?.coveragePercentage != null) {
    baseCoveragePercentage = patient.convention.coveragePercentage;
  }

  // ========================================
  // APPROVAL VALIDATION PER ITEM
  // ========================================
  let totalCompanyShare = 0;
  let totalPatientShare = 0;
  const itemsNeedingApproval = [];
  const approvalWarnings = [];
  let hasApprovalIssues = false;

  // Track cumulative company share per category for annual limits
  const categoryCompanyShareCumulative = {};

  for (let i = 0; i < this.items.length; i++) {
    const item = this.items[i];
    const itemTotal = (item.quantity || 1) * (item.unitPrice || 0);
    const category = item.category || 'other';

    // Initialize cumulative tracker with YTD usage
    if (categoryCompanyShareCumulative[category] === undefined) {
      categoryCompanyShareCumulative[category] = ytdUsage[category]?.totalCompanyShare || 0;
    }

    // Check if this item requires approval
    let approvalRequired = false;
    let approvalReason = null;

    // Check specific acts requiring approval
    if (company.actsRequiringApproval && company.actsRequiringApproval.length > 0) {
      const specificAct = company.actsRequiringApproval.find(
        a => a.actCode && a.actCode.toUpperCase() === item.code?.toUpperCase()
      );
      if (specificAct) {
        approvalRequired = true;
        approvalReason = specificAct.reason || 'Acte spécifique nécessitant une approbation';
      }
    }

    // Check category-level approval requirement
    if (!approvalRequired && company.coveredCategories && company.coveredCategories.length > 0) {
      const categorySettings = company.coveredCategories.find(c => c.category === item.category);
      if (categorySettings && categorySettings.requiresApproval) {
        approvalRequired = true;
        approvalReason = `Catégorie "${item.category}" nécessite une approbation`;
      }
    }

    // Set item approval status
    item.approvalRequired = approvalRequired;

    if (approvalRequired) {
      // Check for valid approval (délibération)
      const now = new Date();
      const approval = await Approval.findOne({
        patient: this.patient,
        company: company._id,
        actCode: item.code?.toUpperCase(),
        status: 'approved',
        $or: [
          { validFrom: null },
          { validFrom: { $lte: now } }
        ]
      }).sort({ createdAt: -1 });

      // Check validity
      const isValid = approval &&
        (!approval.validUntil || new Date(approval.validUntil) >= now) &&
        (!approval.quantityApproved || approval.usedCount < approval.quantityApproved);

      if (isValid) {
        // Valid approval found - apply company coverage
        item.approval = approval._id;
        item.approvalStatus = 'approved';

        // Get coverage for this category
        const categorySettings = company.getCategorySettings(item.category);
        let itemCoveragePercentage = categorySettings.percentage ?? baseCoveragePercentage;

        // If in waiting period and not bypassed, set coverage to 0
        if (waitingPeriodWarning && !options.bypassWaitingPeriod) {
          itemCoveragePercentage = 0;
        }

        let itemCompanyShare = Math.round((itemTotal * itemCoveragePercentage) / 100);

        // Apply category max per item if set
        if (categorySettings.maxAmount && itemCompanyShare > categorySettings.maxAmount) {
          itemCompanyShare = categorySettings.maxAmount;
        }

        // ========================================
        // ANNUAL CATEGORY LIMIT CHECK
        // ========================================
        if (categorySettings.maxPerCategory && categorySettings.maxPerCategory > 0) {
          const annualLimit = categorySettings.maxPerCategory;
          const currentYTD = categoryCompanyShareCumulative[category];
          const remainingBudget = annualLimit - currentYTD;

          if (remainingBudget <= 0) {
            // Annual budget exhausted - patient pays 100%
            annualLimitWarnings.push(`Ligne ${i + 1} (${item.description}): Plafond annuel ${category} épuisé (${annualLimit} ${company.defaultCoverage?.currency || 'CDF'}/an)`);
            item.annualLimitExceeded = true;
            itemCompanyShare = 0;
          } else if (itemCompanyShare > remainingBudget) {
            // Partial coverage - company pays what's left
            annualLimitWarnings.push(`Ligne ${i + 1} (${item.description}): Plafond annuel ${category} partiellement épuisé - reste ${remainingBudget} sur ${annualLimit}`);
            item.annualLimitPartial = true;
            itemCompanyShare = remainingBudget;
          }
        }

        // Update cumulative tracker
        categoryCompanyShareCumulative[category] += itemCompanyShare;
        item.companyShare = itemCompanyShare;
        item.patientShare = itemTotal - itemCompanyShare;

        totalCompanyShare += itemCompanyShare;
        totalPatientShare += (itemTotal - itemCompanyShare);

        // Check if approved amount is sufficient
        if (approval.approvedAmount && itemTotal > approval.approvedAmount) {
          approvalWarnings.push(`Ligne ${i + 1} (${item.description}): Montant approuvé (${approval.approvedAmount}) < facturé (${itemTotal})`);
        }
      } else {
        // No valid approval - patient pays 100%
        item.approval = null;
        item.approvalStatus = 'missing';
        item.companyShare = 0;
        item.patientShare = itemTotal;

        totalCompanyShare += 0;
        totalPatientShare += itemTotal;
        hasApprovalIssues = true;

        itemsNeedingApproval.push({
          index: i,
          code: item.code,
          description: item.description,
          amount: itemTotal,
          reason: approvalReason
        });

        approvalWarnings.push(`Ligne ${i + 1} (${item.description}): Délibération manquante - Patient responsable à 100%`);
      }
    } else {
      // No approval required - apply standard coverage
      item.approvalStatus = 'not_required';

      const categorySettings = company.getCategorySettings(item.category);
      let itemCoveragePercentage = categorySettings.percentage ?? baseCoveragePercentage;

      // If in waiting period and not bypassed, set coverage to 0
      if (waitingPeriodWarning && !options.bypassWaitingPeriod) {
        itemCoveragePercentage = 0;
      }

      let itemCompanyShare = Math.round((itemTotal * itemCoveragePercentage) / 100);

      // Apply category max per item if set
      if (categorySettings.maxAmount && itemCompanyShare > categorySettings.maxAmount) {
        itemCompanyShare = categorySettings.maxAmount;
      }

      // ========================================
      // ANNUAL CATEGORY LIMIT CHECK
      // ========================================
      if (categorySettings.maxPerCategory && categorySettings.maxPerCategory > 0) {
        const annualLimit = categorySettings.maxPerCategory;
        const currentYTD = categoryCompanyShareCumulative[category];
        const remainingBudget = annualLimit - currentYTD;

        if (remainingBudget <= 0) {
          // Annual budget exhausted - patient pays 100%
          annualLimitWarnings.push(`Ligne ${i + 1} (${item.description}): Plafond annuel ${category} épuisé (${annualLimit} ${company.defaultCoverage?.currency || 'CDF'}/an)`);
          item.annualLimitExceeded = true;
          itemCompanyShare = 0;
        } else if (itemCompanyShare > remainingBudget) {
          // Partial coverage - company pays what's left
          annualLimitWarnings.push(`Ligne ${i + 1} (${item.description}): Plafond annuel ${category} partiellement épuisé - reste ${remainingBudget} sur ${annualLimit}`);
          item.annualLimitPartial = true;
          itemCompanyShare = remainingBudget;
        }
      }

      // Update cumulative tracker
      categoryCompanyShareCumulative[category] += itemCompanyShare;
      item.companyShare = itemCompanyShare;
      item.patientShare = itemTotal - itemCompanyShare;

      totalCompanyShare += itemCompanyShare;
      totalPatientShare += (itemTotal - itemCompanyShare);
    }
  }

  // Apply max per visit limit if set
  if (company.defaultCoverage.maxPerVisit && totalCompanyShare > company.defaultCoverage.maxPerVisit) {
    const excess = totalCompanyShare - company.defaultCoverage.maxPerVisit;
    totalCompanyShare = company.defaultCoverage.maxPerVisit;
    totalPatientShare += excess;
    approvalWarnings.push(`Plafond par visite (${company.defaultCoverage.maxPerVisit} ${company.defaultCoverage.currency}) appliqué`);
  }

  const total = this.summary.total;
  const effectiveCoveragePercentage = total > 0 ? Math.round((totalCompanyShare / total) * 100) : 0;

  // Calculate USD amounts if exchange rate provided
  let companyShareUSD = null;
  let patientShareUSD = null;
  let totalUSD = null;
  if (exchangeRateUSD && exchangeRateUSD > 0) {
    companyShareUSD = Math.round((totalCompanyShare / exchangeRateUSD) * 100) / 100;
    patientShareUSD = Math.round((totalPatientShare / exchangeRateUSD) * 100) / 100;
    totalUSD = Math.round((total / exchangeRateUSD) * 100) / 100;
  }

  // Combine all warnings
  const allWarnings = [];
  if (waitingPeriodWarning) allWarnings.push(waitingPeriodWarning);
  allWarnings.push(...approvalWarnings);
  allWarnings.push(...annualLimitWarnings);

  // Set company billing info
  this.companyBilling = {
    company: company._id,
    companyName: company.name,
    companyId: company.companyId,
    employeeId: patient.convention?.employeeId,
    beneficiaryType: patient.convention?.beneficiaryType || 'employee',
    coveragePercentage: effectiveCoveragePercentage, // Effective after approval validation
    baseCoveragePercentage, // Original before approval validation
    companyShare: totalCompanyShare,
    patientShare: totalPatientShare,
    companyShareUSD,
    patientShareUSD,
    totalUSD,
    feeSchedule: feeSchedule?._id,
    companyInvoiceStatus: 'pending',
    hasApprovalIssues,
    hasAnnualLimitIssues: annualLimitWarnings.length > 0,
    hasWaitingPeriodIssue: !!waitingPeriodWarning,
    itemsNeedingApproval: itemsNeedingApproval.length,
    billingNotes: allWarnings.length > 0 ? allWarnings.join('\n') : null
  };

  this.isConventionInvoice = true;

  // Record edit
  this.recordEdit('update', {
    action: 'company_billing_applied',
    companyId: company.companyId,
    baseCoveragePercentage,
    effectiveCoveragePercentage,
    companyShare: totalCompanyShare,
    patientShare: totalPatientShare,
    hasApprovalIssues,
    hasAnnualLimitIssues: annualLimitWarnings.length > 0,
    hasWaitingPeriodIssue: !!waitingPeriodWarning,
    itemsNeedingApproval: itemsNeedingApproval.length
  }, {}, userId, `Facturation convention appliquée: ${company.name}${hasApprovalIssues ? ' (délibérations manquantes)' : ''}${annualLimitWarnings.length > 0 ? ' (plafonds annuels)' : ''}`);

  this.updatedBy = userId;
  await this.save();

  // Update company balance (only for company share)
  if (totalCompanyShare > 0) {
    await company.updateBalance(totalCompanyShare, 'billed');
  }

  return {
    invoice: this,
    summary: {
      total,
      companyShare: totalCompanyShare,
      patientShare: totalPatientShare,
      baseCoveragePercentage,
      effectiveCoveragePercentage,
      ytdUsageByCategory: ytdUsage
    },
    approvalIssues: {
      hasIssues: hasApprovalIssues,
      itemsNeedingApproval,
      warnings: approvalWarnings
    },
    annualLimitIssues: {
      hasIssues: annualLimitWarnings.length > 0,
      warnings: annualLimitWarnings
    },
    waitingPeriod: {
      hasIssue: !!waitingPeriodWarning,
      warning: waitingPeriodWarning
    }
  };
};

// Method to mark item as realized
invoiceSchema.methods.markItemRealized = async function(itemIndex, userId, notes = '') {
  if (!this.items[itemIndex]) {
    throw new Error('Article non trouvé');
  }

  const item = this.items[itemIndex];

  if (item.realization?.realized) {
    throw new Error('Cet acte est déjà réalisé');
  }

  // Check if approval is required and approved
  if (item.approvalRequired && item.approvalStatus !== 'approved') {
    throw new Error('Cet acte nécessite une approbation préalable');
  }

  item.realization = {
    realized: true,
    realizedAt: new Date(),
    realizedBy: userId,
    notes
  };

  this.recordEdit('update', {
    action: 'item_realized',
    itemIndex,
    itemDescription: item.description,
    itemCode: item.code
  }, {}, userId, `Acte réalisé: ${item.description}`);

  this.updatedBy = userId;
  await this.save();

  return this;
};

// Method to mark multiple items as realized
invoiceSchema.methods.markAllRealized = async function(userId, notes = '') {
  let realizedCount = 0;

  for (let i = 0; i < this.items.length; i++) {
    const item = this.items[i];

    // Skip already realized items
    if (item.realization?.realized) continue;

    // Skip items requiring approval that aren't approved
    if (item.approvalRequired && item.approvalStatus !== 'approved') continue;

    item.realization = {
      realized: true,
      realizedAt: new Date(),
      realizedBy: userId,
      notes
    };
    realizedCount++;
  }

  if (realizedCount > 0) {
    this.recordEdit('update', {
      action: 'bulk_items_realized',
      count: realizedCount
    }, {}, userId, `${realizedCount} acte(s) réalisé(s)`);

    this.updatedBy = userId;
    await this.save();
  }

  return { realizedCount, totalItems: this.items.length };
};

// Method to consume approvals (délibérations) when invoice is finalized/paid
invoiceSchema.methods.consumeApprovals = async function(userId) {
  if (!this.isConventionInvoice) {
    return { consumed: [], errors: [] };
  }

  const Approval = mongoose.model('Approval');
  const consumed = [];
  const errors = [];

  for (const item of this.items) {
    // Only process items that have linked approvals
    if (item.approval && item.approvalStatus === 'approved') {
      try {
        const approval = await Approval.findById(item.approval);

        if (approval && approval.isUsable) {
          await approval.use(userId, this._id, item.quantity || 1, `Facture ${this.invoiceId}`);
          consumed.push({
            approvalId: approval.approvalId,
            actCode: item.code,
            description: item.description,
            quantity: item.quantity || 1
          });
        } else if (approval) {
          errors.push({
            approvalId: approval.approvalId,
            actCode: item.code,
            error: 'Délibération non valide ou déjà utilisée'
          });
        }
      } catch (error) {
        errors.push({
          approvalId: item.approval?.toString(),
          actCode: item.code,
          error: error.message
        });
      }
    }
  }

  // Record in edit history
  if (consumed.length > 0) {
    this.recordEdit('update', {
      action: 'approvals_consumed',
      consumed: consumed.map(c => c.approvalId),
      count: consumed.length
    }, {}, userId, `${consumed.length} délibération(s) consommée(s)`);

    this.updatedBy = userId;
    await this.save();
  }

  return { consumed, errors };
};

// Method to update company invoice status
invoiceSchema.methods.updateCompanyInvoiceStatus = async function(status, userId, reference = null, notes = null) {
  if (!this.isConventionInvoice || !this.companyBilling?.company) {
    throw new Error('Cette facture n\'est pas une facture convention');
  }

  const previousStatus = this.companyBilling.companyInvoiceStatus;

  this.companyBilling.companyInvoiceStatus = status;

  if (status === 'sent') {
    this.companyBilling.companyInvoiceSentAt = new Date();
  }

  if (reference) {
    this.companyBilling.companyInvoiceReference = reference;
  }

  if (notes) {
    this.companyBilling.billingNotes = notes;
  }

  this.recordEdit('status_change', {
    field: 'companyInvoiceStatus',
    from: previousStatus,
    to: status
  }, { companyInvoiceStatus: previousStatus }, userId, `Statut facturation entreprise: ${status}`);

  this.updatedBy = userId;
  await this.save();

  return this;
};

// Method to record company payment
invoiceSchema.methods.recordCompanyPayment = async function(amount, userId, reference = '', notes = '') {
  if (!this.isConventionInvoice || !this.companyBilling?.company) {
    throw new Error('Cette facture n\'est pas une facture convention');
  }

  const Company = mongoose.model('Company');

  this.companyBilling.companyPayment = {
    amount,
    paidAt: new Date(),
    reference,
    notes
  };

  // Update status based on payment
  if (amount >= this.companyBilling.companyShare) {
    this.companyBilling.companyInvoiceStatus = 'paid';
  } else if (amount > 0) {
    this.companyBilling.companyInvoiceStatus = 'partial';
  }

  this.recordEdit('payment_added', {
    type: 'company_payment',
    amount,
    reference
  }, {}, userId, `Paiement entreprise: ${amount} CDF`);

  this.updatedBy = userId;
  await this.save();

  // Update company balance
  const company = await Company.findById(this.companyBilling.company);
  if (company) {
    await company.updateBalance(amount, 'paid');
  }

  return this;
};

// Static method to get company invoices
invoiceSchema.statics.getCompanyInvoices = async function(companyId, options = {}) {
  const query = {
    'companyBilling.company': companyId,
    isConventionInvoice: true,
    status: { $nin: ['cancelled', 'refunded'] }
  };

  if (options.status) {
    query['companyBilling.companyInvoiceStatus'] = options.status;
  }

  if (options.startDate || options.endDate) {
    query.dateIssued = {};
    if (options.startDate) query.dateIssued.$gte = new Date(options.startDate);
    if (options.endDate) query.dateIssued.$lte = new Date(options.endDate);
  }

  return this.find(query)
    .populate('patient', 'firstName lastName patientId')
    .sort({ dateIssued: -1 });
};

// Static method to get company billing summary
invoiceSchema.statics.getCompanyBillingSummary = async function(companyId, startDate = null, endDate = null) {
  const matchQuery = {
    'companyBilling.company': new mongoose.Types.ObjectId(companyId),
    isConventionInvoice: true,
    status: { $nin: ['cancelled', 'refunded'] }
  };

  if (startDate || endDate) {
    matchQuery.dateIssued = {};
    if (startDate) matchQuery.dateIssued.$gte = new Date(startDate);
    if (endDate) matchQuery.dateIssued.$lte = new Date(endDate);
  }

  const result = await this.aggregate([
    { $match: matchQuery },
    {
      $group: {
        _id: '$companyBilling.companyInvoiceStatus',
        count: { $sum: 1 },
        totalBilled: { $sum: '$companyBilling.companyShare' },
        totalPaid: { $sum: { $ifNull: ['$companyBilling.companyPayment.amount', 0] } }
      }
    }
  ]);

  const summary = {
    pending: { count: 0, amount: 0 },
    sent: { count: 0, amount: 0 },
    paid: { count: 0, amount: 0 },
    partial: { count: 0, amount: 0 },
    total: { count: 0, billed: 0, paid: 0, outstanding: 0 }
  };

  for (const item of result) {
    if (summary[item._id]) {
      summary[item._id] = {
        count: item.count,
        amount: item.totalBilled
      };
    }
    summary.total.count += item.count;
    summary.total.billed += item.totalBilled;
    summary.total.paid += item.totalPaid;
  }

  summary.total.outstanding = summary.total.billed - summary.total.paid;

  return summary;
};

// Static method to get unrealized items report
invoiceSchema.statics.getUnrealizedItems = async function(options = {}) {
  const matchQuery = {
    status: { $nin: ['cancelled', 'refunded'] },
    'items.realization.realized': { $ne: true }
  };

  if (options.companyId) {
    matchQuery['companyBilling.company'] = new mongoose.Types.ObjectId(options.companyId);
  }

  if (options.startDate || options.endDate) {
    matchQuery.dateIssued = {};
    if (options.startDate) matchQuery.dateIssued.$gte = new Date(options.startDate);
    if (options.endDate) matchQuery.dateIssued.$lte = new Date(options.endDate);
  }

  return this.find(matchQuery)
    .populate('patient', 'firstName lastName patientId')
    .populate('companyBilling.company', 'name companyId')
    .select('invoiceId patient dateIssued items companyBilling')
    .sort({ dateIssued: -1 });
};

// Static method to get invoice edit history with populated user info
invoiceSchema.statics.getInvoiceHistory = async function(invoiceId) {
  const invoice = await this.findById(invoiceId)
    .select('invoiceId editHistory version')
    .populate('editHistory.editedBy', 'firstName lastName email');

  if (!invoice) {
    throw new Error('Invoice not found');
  }

  return {
    invoiceId: invoice.invoiceId,
    version: invoice.version,
    history: invoice.editHistory?.sort((a, b) => b.editedAt - a.editedAt) || []
  };
};

// Static method to get overdue invoices
invoiceSchema.statics.getOverdueInvoices = async function(additionalFilter = {}) {
  const today = new Date();
  return this.find({
    ...additionalFilter,
    status: { $in: ['issued', 'sent', 'viewed', 'partial'] },
    dueDate: { $lt: today },
    'summary.amountDue': { $gt: 0 }
  }).populate('patient', 'firstName lastName patientId phoneNumber email');
};

// Static method to get patient balance
invoiceSchema.statics.getPatientBalance = async function(patientId) {
  const invoices = await this.find({
    patient: patientId,
    status: { $nin: ['cancelled', 'refunded'] }
  });

  const total = invoices.reduce((sum, inv) => sum + inv.summary.total, 0);
  const paid = invoices.reduce((sum, inv) => sum + inv.summary.amountPaid, 0);
  const due = invoices.reduce((sum, inv) => sum + inv.summary.amountDue, 0);

  return { total, paid, due };
};

// Post-save hook to update Patient.invoices array and account balance
invoiceSchema.post('save', async (doc) => {
  if (!doc.patient) return;

  try {
    const Patient = mongoose.model('Patient');

    // Add to patient's invoices array if new invoice
    if (doc.wasNew) {
      await Patient.findByIdAndUpdate(
        doc.patient,
        { $addToSet: { invoices: doc._id } },
        { new: true }
      );
    }

    // Always update patient's account balance after invoice changes
    // This catches: new invoices, payment additions, status changes, etc.
    // Use non-blocking async update to avoid slowing down invoice operations
    setImmediate(async () => {
      try {
        await Patient.updatePatientBalance(doc.patient);
      } catch (err) {
        console.error('Error updating patient balance after invoice save:', err.message);
      }
    });

    // AUTO-DISPENSE: When invoice is fully paid, dispense linked prescriptions
    // Trigger on any paid invoice - the dispense function will skip already-dispensed prescriptions
    if (doc.status === 'paid') {
      console.log(`[Invoice ${doc.invoiceId}] Invoice is paid - checking for prescriptions to auto-dispense...`);
      setImmediate(async () => {
        try {
          await autoDispensePrescriptionsForInvoice(doc);
        } catch (err) {
          console.error('[Invoice] Error auto-dispensing prescriptions:', err.message);
        }
      });
    }

    // UPDATE COMPANY USAGE: When convention invoice is finalized, update cached usage
    // This keeps the CompanyUsage cache in sync for fast annual cap lookups
    if (doc.isConventionInvoice && doc.companyBilling?.company) {
      // Track if this is a status change that should trigger usage update
      const originalStatus = doc._original?.status;
      const isNewConventionInvoice = doc.wasNew && ['issued', 'paid'].includes(doc.status);
      const becameFinalized = originalStatus === 'draft' && ['issued', 'paid'].includes(doc.status);
      const wasCancelled = ['cancelled', 'voided', 'refunded'].includes(doc.status) &&
                           !['cancelled', 'voided', 'refunded'].includes(originalStatus);

      if (isNewConventionInvoice || becameFinalized) {
        setImmediate(async () => {
          try {
            const CompanyUsage = mongoose.model('CompanyUsage');
            await CompanyUsage.recordInvoiceUsage(doc);
            console.log(`[Invoice ${doc.invoiceId}] Updated CompanyUsage cache`);
          } catch (err) {
            console.error('[Invoice] Error updating CompanyUsage:', err.message);
            // Non-blocking - cache will be rebuilt on next access if needed
          }
        });
      } else if (wasCancelled) {
        setImmediate(async () => {
          try {
            const CompanyUsage = mongoose.model('CompanyUsage');
            await CompanyUsage.reverseInvoiceUsage(doc, doc.updatedBy || doc.createdBy, `Invoice ${doc.status}`);
            console.log(`[Invoice ${doc.invoiceId}] Reversed CompanyUsage for ${doc.status}`);
          } catch (err) {
            console.error('[Invoice] Error reversing CompanyUsage:', err.message);
          }
        });
      }
    }
  } catch (err) {
    console.error('Error in invoice post-save hook:', err);
  }
});

/**
 * Auto-dispense prescriptions linked to invoice when payment is complete
 * Supports both:
 * 1. Invoice items with prescription references (reference: "Prescription:xxx")
 * 2. Visit-linked invoices - finds all prescriptions for the visit
 * @param {Object} invoice - The paid invoice document
 */
async function autoDispensePrescriptionsForInvoice(invoice) {
  const Prescription = mongoose.model('Prescription');
  const PharmacyInventory = mongoose.model('PharmacyInventory');
  const Visit = mongoose.model('Visit');

  const prescriptionsToDispense = new Set();

  // Method 1: Find prescriptions from invoice item references
  // Also detect medications by code pattern (MED_*) or category
  if (invoice.items && invoice.items.length > 0) {
    const medicationItems = invoice.items.filter(item =>
      item.category === 'medication' ||
      (item.code && item.code.startsWith('MED_')) ||
      (item.description && /tablet|capsule|injection|drops|syrup|cream|gel|ointment/i.test(item.description))
    );

    if (medicationItems.length > 0) {
      console.log(`[Invoice ${invoice.invoiceId}] Found ${medicationItems.length} medication items on invoice`);
    }

    for (const item of medicationItems) {
      if (item.reference) {
        const ref = item.reference;
        if (ref.startsWith('Prescription:')) {
          prescriptionsToDispense.add(ref.replace('Prescription:', ''));
        } else if (mongoose.isValidObjectId(ref)) {
          prescriptionsToDispense.add(ref);
        }
      }
    }
  }

  // Method 2: Find prescriptions from linked visit
  if (invoice.visit) {
    try {
      const visit = await Visit.findById(invoice.visit).select('prescriptions');
      if (visit && visit.prescriptions && visit.prescriptions.length > 0) {
        for (const prescId of visit.prescriptions) {
          prescriptionsToDispense.add(prescId.toString());
        }
        console.log(`[Invoice ${invoice.invoiceId}] Found ${visit.prescriptions.length} prescriptions from linked visit`);
      }
    } catch (err) {
      console.error(`[Invoice ${invoice.invoiceId}] Error fetching visit prescriptions:`, err.message);
    }
  }

  // Method 3: Find prescriptions directly linked to this invoice
  if (invoice.prescription) {
    prescriptionsToDispense.add(invoice.prescription.toString());
  }

  // Method 4: SAFETY FIX - Only search for prescriptions from the SAME VISIT
  // Previously this could accidentally dispense prescriptions from unrelated visits
  // Now it REQUIRES a linked visit and ONLY searches that specific visit
  if (prescriptionsToDispense.size === 0 && invoice.patient && invoice.visit) {
    const hasMedicationItems = invoice.items?.some(item =>
      item.category === 'medication' ||
      (item.code && item.code.startsWith('MED_')) ||
      (item.description && /tablet|capsule|injection|drops|syrup|cream|gel|ointment/i.test(item.description))
    );

    if (hasMedicationItems) {
      console.log(`[Invoice ${invoice.invoiceId}] Medications on invoice but no prescription refs - searching prescriptions from same visit only`);

      try {
        // CRITICAL: Only search for prescriptions from the EXACT same visit
        // Do NOT fall back to searching all patient prescriptions
        const visitPrescriptions = await Prescription.find({
          patient: invoice.patient,
          visit: invoice.visit,  // MUST match the visit
          type: 'medication',
          status: 'pending'
        }).select('_id prescriptionId');

        if (visitPrescriptions.length > 0) {
          console.log(`[Invoice ${invoice.invoiceId}] Found ${visitPrescriptions.length} pending prescriptions from same visit`);
          for (const p of visitPrescriptions) {
            prescriptionsToDispense.add(p._id.toString());
          }
        }
        // NOTE: No fallback! If no prescriptions found for this visit, don't search other visits
      } catch (err) {
        console.error(`[Invoice ${invoice.invoiceId}] Error searching visit prescriptions:`, err.message);
      }
    }
  }

  if (prescriptionsToDispense.size === 0) {
    console.log(`[Invoice ${invoice.invoiceId}] No prescriptions to auto-dispense`);
    return;
  }

  console.log(`[Invoice ${invoice.invoiceId}] Auto-dispensing ${prescriptionsToDispense.size} prescription(s) after payment`);

  // Process each prescription
  for (const prescriptionId of prescriptionsToDispense) {
    try {
      // CRITICAL FIX: Use atomic findOneAndUpdate to prevent race conditions
      // This ensures only ONE process can dispense a prescription
      const prescription = await Prescription.findOneAndUpdate(
        {
          _id: prescriptionId,
          type: 'medication',
          status: { $nin: ['dispensed', 'cancelled'] },
          'autoDispenseInProgress': { $ne: true }
        },
        {
          $set: {
            autoDispenseInProgress: true,
            autoDispenseStartedAt: new Date(),
            autoDispenseInvoice: invoice._id
          }
        },
        { new: true }
      );

      if (!prescription) {
        // Either not found, already dispensed, or being processed by another
        console.log(`[Invoice ${invoice.invoiceId}] Prescription ${prescriptionId} skipped (not found, already dispensed, or being processed)`);
        continue;
      }

      console.log(`[Invoice ${invoice.invoiceId}] Locked and dispensing prescription ${prescription.prescriptionId || prescriptionId}`);

      // Dispense each medication and deduct inventory
      const dispensingRecord = {
        dispensedAt: new Date(),
        dispensedBy: invoice.updatedBy || invoice.createdBy,
        notes: `Auto-dispensed on payment of invoice ${invoice.invoiceId}`,
        invoiceId: invoice._id,
        inventoryDeducted: false
      };

      let inventoryDeductedCount = 0;

      for (const medication of prescription.medications || []) {
        // Skip if already dispensed
        if (medication.dispensing?.dispensed) {
          continue;
        }

        const quantityToDispense = medication.quantity || 1;

        // Find inventory item
        let inventoryItem = null;

        if (medication.inventoryItem) {
          inventoryItem = await PharmacyInventory.findById(medication.inventoryItem);
        }

        // If no direct reference, try to find by medication name
        if (!inventoryItem && medication.name) {
          const escapedMedName = medication.name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          inventoryItem = await PharmacyInventory.findOne({
            $or: [
              { 'medication.genericName': { $regex: new RegExp(escapedMedName, 'i') } },
              { 'medication.brandName': { $regex: new RegExp(escapedMedName, 'i') } }
            ]
          });
        }

        if (inventoryItem) {
          // Check if sufficient stock
          if (inventoryItem.inventory.currentStock >= quantityToDispense) {
            // Deduct stock
            inventoryItem.inventory.currentStock -= quantityToDispense;

            // Update stock status
            if (inventoryItem.inventory.currentStock <= 0) {
              inventoryItem.inventory.status = 'out-of-stock';
            } else if (inventoryItem.inventory.currentStock <= (inventoryItem.inventory.reorderPoint || inventoryItem.inventory.minimumStock || 10)) {
              inventoryItem.inventory.status = 'low-stock';
            }

            // Add to dispensing history
            if (!inventoryItem.usage) inventoryItem.usage = { dispensingHistory: [] };
            if (!inventoryItem.usage.dispensingHistory) inventoryItem.usage.dispensingHistory = [];

            inventoryItem.usage.dispensingHistory.push({
              date: new Date(),
              quantity: quantityToDispense,
              prescription: prescription._id,
              patient: prescription.patient,
              dispensedBy: invoice.updatedBy || invoice.createdBy
            });

            // Add transaction record
            if (!inventoryItem.transactions) inventoryItem.transactions = [];
            inventoryItem.transactions.push({
              type: 'dispensed',
              quantity: quantityToDispense,
              date: new Date(),
              performedBy: invoice.updatedBy || invoice.createdBy,
              reference: `Invoice ${invoice.invoiceId} - Prescription ${prescription._id}`,
              notes: 'Auto-dispensed on payment'
            });

            await inventoryItem.save();
            inventoryDeductedCount++;

            console.log(`[Invoice ${invoice.invoiceId}] Deducted ${quantityToDispense} ${medication.name} from inventory. Remaining: ${inventoryItem.inventory.currentStock}`);
          } else {
            console.warn(`[Invoice ${invoice.invoiceId}] Insufficient stock for ${medication.name}. Available: ${inventoryItem.inventory.currentStock}, Required: ${quantityToDispense}`);
          }
        }

        // Mark medication as dispensed in prescription
        medication.dispensing = {
          dispensed: true,
          dispensedQuantity: quantityToDispense,
          dispensedAt: new Date(),
          dispensedBy: invoice.updatedBy || invoice.createdBy,
          invoiceId: invoice._id
        };
      }

      // Update prescription status and clear the lock
      dispensingRecord.inventoryDeducted = inventoryDeductedCount > 0;
      prescription.dispensing = prescription.dispensing || [];
      prescription.dispensing.push(dispensingRecord);
      prescription.status = 'dispensed';
      prescription.dispensedAt = new Date();

      // Clear the auto-dispense lock fields
      prescription.autoDispenseInProgress = undefined;
      prescription.autoDispenseStartedAt = undefined;
      prescription.autoDispenseInvoice = undefined;

      await prescription.save();

      console.log(`[Invoice ${invoice.invoiceId}] Successfully dispensed prescription ${prescription.prescriptionId || prescriptionId}`);

    } catch (err) {
      console.error(`[Invoice ${invoice.invoiceId}] Error dispensing prescription ${prescriptionId}:`, err.message);

      // CRITICAL: Release the lock on error so it can be retried
      try {
        await Prescription.findByIdAndUpdate(prescriptionId, {
          $unset: {
            autoDispenseInProgress: '',
            autoDispenseStartedAt: '',
            autoDispenseInvoice: ''
          }
        });
      } catch (unlockErr) {
        console.error(`[Invoice ${invoice.invoiceId}] Failed to release lock on prescription ${prescriptionId}:`, unlockErr.message);
      }
    }
  }
}

// Track if document is new and if status is changing to 'paid' for post-save hook
invoiceSchema.pre('save', function(next) {
  this.wasNew = this.isNew;

  // Track if status is changing to 'paid' to trigger auto-dispense
  if (!this.isNew && this.isModified('status')) {
    this._previousStatus = this._original?.status;
    this._statusChangedToPaid = this.status === 'paid' && this._previousStatus !== 'paid';
  }

  next();
});

// Store original document for comparison
invoiceSchema.post('init', function(doc) {
  this._original = doc.toObject();
});

// NOTE: Patient.accountBalance update is handled by the post-save hook above (lines 2229-2235)
// that uses setImmediate to asynchronously call Patient.updatePatientBalance(doc.patient)
// This comment documents the data cascade for maintainability.

module.exports = mongoose.model('Invoice', invoiceSchema);
