const mongoose = require('mongoose');
const Counter = require('./Counter');

const appointmentSchema = new mongoose.Schema({
  // Identification
  appointmentId: {
    type: String,
    unique: true,
    required: false  // Generated by pre-save hook
  },

  // Patient Information
  patient: {
    type: mongoose.Schema.ObjectId,
    ref: 'Patient',
    required: true
  },

  // Provider Information
  provider: {
    type: mongoose.Schema.ObjectId,
    ref: 'User',
    required: true
  },
  requestedProvider: {
    type: mongoose.Schema.ObjectId,
    ref: 'User'
  },

  // Multi-Clinic: Which clinic this appointment is at
  clinic: {
    type: mongoose.Schema.ObjectId,
    ref: 'Clinic',
    index: true
  },

  // Scheduling Details
  date: {
    type: Date,
    required: true
  },
  startTime: {
    type: String,
    required: true
  },
  endTime: {
    type: String,
    required: true
  },
  duration: {
    type: Number, // in minutes
    default: 30
  },

  // Appointment Type
  type: {
    type: String,
    enum: [
      'consultation',
      'follow-up',
      'emergency',
      'routine-checkup',
      'vaccination',
      'lab-test',
      'imaging',
      'procedure',
      'surgery',
      'ophthalmology',
      'refraction',
      'telemedicine'
    ],
    required: true
  },
  subType: String, // For more specific categorization

  // Department and Service
  department: {
    type: String,
    enum: ['general', 'ophthalmology', 'pediatrics', 'cardiology', 'orthopedics', 'emergency', 'laboratory', 'radiology'],
    required: true
  },
  service: {
    type: mongoose.Schema.ObjectId,
    ref: 'Service'
  },

  // Status
  status: {
    type: String,
    enum: [
      'scheduled',
      'confirmed',
      'checked-in',
      'in-progress',
      'completed',
      'cancelled',
      'no-show',
      'rescheduled'
    ],
    default: 'scheduled'
  },

  // Priority
  priority: {
    type: String,
    enum: ['normal', 'high', 'urgent', 'emergency', 'vip', 'pregnant', 'elderly'],
    default: 'normal'
  },

  // Reason and Notes
  reason: {
    type: String,
    required: true
  },
  symptoms: [String],
  chiefComplaint: String,
  notes: String,
  internalNotes: String, // Staff-only notes

  // Location
  location: {
    room: String,
    floor: String,
    building: String,
    address: String,
    isVirtual: {
      type: Boolean,
      default: false
    },
    virtualLink: String
  },

  // Queue Management
  queueNumber: Number,
  checkInTime: Date,
  waitingTime: Number, // in minutes
  consultationStartTime: Date,
  consultationEndTime: Date,

  // Reminders
  reminders: [{
    type: {
      type: String,
      enum: ['email', 'sms', 'push', 'call']
    },
    scheduledFor: Date,
    sent: {
      type: Boolean,
      default: false
    },
    sentAt: Date,
    status: String,
    error: String
  }],

  // Recurring Appointment
  isRecurring: {
    type: Boolean,
    default: false
  },
  recurrence: {
    pattern: {
      type: String,
      enum: ['daily', 'weekly', 'biweekly', 'monthly', 'yearly']
    },
    interval: Number,
    daysOfWeek: [Number], // 0-6 (Sunday-Saturday)
    dayOfMonth: Number,
    endDate: Date,
    occurrences: Number,
    parentAppointment: {
      type: mongoose.Schema.ObjectId,
      ref: 'Appointment'
    }
  },

  // Preparation Instructions
  preparation: {
    instructions: String,
    fasting: {
      required: Boolean,
      hours: Number
    },
    medications: {
      stop: [String],
      continue: [String]
    },
    documents: [String]
  },

  // Results and Follow-up
  outcome: {
    diagnosis: [String],
    procedures: [String],
    prescriptions: [{
      type: mongoose.Schema.ObjectId,
      ref: 'Prescription'
    }],
    labOrders: [{
      type: mongoose.Schema.ObjectId,
      ref: 'LabOrder'
    }],
    imagingOrders: [{
      type: mongoose.Schema.ObjectId,
      ref: 'ImagingOrder'
    }],
    followUpRequired: Boolean,
    followUpScheduled: Boolean,
    followUpDate: Date,
    referrals: [{
      to: String,
      reason: String,
      urgency: String,
      date: Date
    }]
  },

  // Documents
  attachments: [{
    name: String,
    type: String,
    url: String,
    uploadedAt: Date,
    uploadedBy: {
      type: mongoose.Schema.ObjectId,
      ref: 'User'
    }
  }],

  // Billing
  billing: {
    status: {
      type: String,
      enum: ['pending', 'processed', 'paid', 'cancelled'],
      default: 'pending'
    },
    invoice: {
      type: mongoose.Schema.ObjectId,
      ref: 'Invoice'
    },
    services: [{
      service: {
        type: mongoose.Schema.ObjectId,
        ref: 'Service'
      },
      quantity: Number,
      price: Number
    }],
    totalAmount: Number,
    insuranceClaim: {
      type: mongoose.Schema.ObjectId,
      ref: 'InsuranceClaim'
    }
  },

  // Cancellation/Rescheduling
  cancellation: {
    cancelledAt: Date,
    cancelledBy: {
      type: mongoose.Schema.ObjectId,
      ref: 'User'
    },
    reason: String,
    fee: Number
  },
  rescheduled: {
    from: Date,
    to: Date,
    by: {
      type: mongoose.Schema.ObjectId,
      ref: 'User'
    },
    reason: String,
    count: {
      type: Number,
      default: 0
    }
  },

  // Confirmation
  confirmation: {
    required: {
      type: Boolean,
      default: true
    },
    confirmed: {
      type: Boolean,
      default: false
    },
    confirmedAt: Date,
    confirmedBy: String, // 'patient', 'staff', 'system'
    method: String // 'phone', 'sms', 'email', 'in-person'
  },

  // Rating and Feedback
  feedback: {
    rating: {
      type: Number,
      min: 1,
      max: 5
    },
    comment: String,
    submittedAt: Date,
    categories: {
      waitTime: Number,
      staffCourtesy: Number,
      cleanliness: Number,
      overallExperience: Number
    }
  },

  // Integration
  externalId: String, // ID from external system
  source: {
    type: String,
    enum: ['web', 'mobile', 'phone', 'walk-in', 'referral', 'recurring'],
    default: 'web'
  },

  // Audit
  createdBy: {
    type: mongoose.Schema.ObjectId,
    ref: 'User'
  },
  updatedBy: {
    type: mongoose.Schema.ObjectId,
    ref: 'User'
  },
  statusHistory: [{
    status: String,
    changedAt: Date,
    changedBy: {
      type: mongoose.Schema.ObjectId,
      ref: 'User'
    },
    reason: String
  }],

  // Related Surgery (for post-op follow-up appointments)
  relatedSurgery: {
    type: mongoose.Schema.ObjectId,
    ref: 'SurgeryCase'
  },

  // Related Glasses Order (for optical follow-up)
  relatedGlassesOrder: {
    type: mongoose.Schema.ObjectId,
    ref: 'GlassesOrder'
  },

  // Linked Visit (populated when appointment is checked-in)
  // Enables bidirectional sync: Appointment ↔ Visit
  visit: {
    type: mongoose.Schema.ObjectId,
    ref: 'Visit',
    index: true
  },

  // Optimistic locking - prevents lost updates from concurrent modifications
  version: {
    type: Number,
    default: 0
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true },
  optimisticConcurrency: true,
  versionKey: 'version'
});

// Indexes
appointmentSchema.index({ patient: 1, date: -1 });
appointmentSchema.index({ provider: 1, date: 1, status: 1 });
appointmentSchema.index({ date: 1, startTime: 1 });
appointmentSchema.index({ status: 1 });
appointmentSchema.index({ type: 1, department: 1 });
appointmentSchema.index({ appointmentId: 1 }, { unique: true });

// Queue performance indexes
appointmentSchema.index({ date: 1, status: 1, department: 1 }); // Queue filtering by department
appointmentSchema.index({ date: 1, status: 1, queueNumber: 1 }); // Queue ordering
appointmentSchema.index({ status: 1, date: 1, priority: 1 }); // Priority queue management

// CRITICAL: Multi-clinic indexes for data isolation
appointmentSchema.index({ clinic: 1, date: 1 }); // Clinic-scoped appointment list
appointmentSchema.index({ clinic: 1, status: 1, date: 1 }); // Clinic-scoped queue
appointmentSchema.index({ clinic: 1, provider: 1, date: 1 }); // Clinic-scoped provider schedule
appointmentSchema.index({ clinic: 1, patient: 1 }); // Clinic-scoped patient history
// Note: Bidirectional reference - Visit.appointment and Appointment.visit both exist

// Virtual for isToday
appointmentSchema.virtual('isToday').get(function() {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const appointmentDate = new Date(this.date);
  appointmentDate.setHours(0, 0, 0, 0);
  return today.getTime() === appointmentDate.getTime();
});

// Virtual for isPast
appointmentSchema.virtual('isPast').get(function() {
  return new Date(this.date) < new Date();
});

// Virtual for isFuture
appointmentSchema.virtual('isFuture').get(function() {
  return new Date(this.date) > new Date();
});

// Valid appointment status transitions (state machine)
const VALID_APPOINTMENT_TRANSITIONS = {
  'scheduled': ['confirmed', 'checked-in', 'cancelled', 'no-show', 'rescheduled'],
  'confirmed': ['checked-in', 'cancelled', 'no-show', 'rescheduled'],
  'checked-in': ['in-progress', 'cancelled', 'no-show'],
  'in-progress': ['completed', 'cancelled'],
  'completed': [], // Terminal state - no transitions allowed
  'cancelled': [], // Terminal state
  'no-show': ['rescheduled', 'scheduled'], // Can reschedule no-show
  'rescheduled': ['scheduled', 'confirmed', 'cancelled']
};

// CRITICAL: Validate status transitions to prevent invalid state changes
appointmentSchema.pre('save', function(next) {
  // Only check on updates, not creates
  if (!this.isNew && this.isModified('status')) {
    const oldStatus = this._previousStatus || 'scheduled';
    const newStatus = this.status;

    const allowedTransitions = VALID_APPOINTMENT_TRANSITIONS[oldStatus] || [];

    if (!allowedTransitions.includes(newStatus)) {
      const error = new Error(
        `Invalid status transition: Cannot change appointment from '${oldStatus}' to '${newStatus}'. ` +
        `Allowed transitions: ${allowedTransitions.join(', ') || 'none (terminal state)'}`
      );
      error.name = 'ValidationError';
      error.statusCode = 400;
      return next(error);
    }
  }
  next();
});

// Store previous status for transition validation
appointmentSchema.pre('find', function() {
  this._previousStatus = this.status;
});

appointmentSchema.pre('findOne', function() {
  this._previousStatus = this.status;
});

// CRITICAL: Validate dates to prevent inappropriate future dates
appointmentSchema.pre('save', function(next) {
  const now = new Date();

  // Check-in time should not be in the future (can't check in before it happens)
  if (this.checkInTime && new Date(this.checkInTime) > now) {
    const error = new Error('Check-in time cannot be in the future');
    error.name = 'ValidationError';
    error.statusCode = 400;
    return next(error);
  }

  // Cancellation time should not be in the future
  if (this.cancellation?.cancelledAt && new Date(this.cancellation.cancelledAt) > now) {
    const error = new Error('Cancellation time cannot be in the future');
    error.name = 'ValidationError';
    error.statusCode = 400;
    return next(error);
  }

  // Completion time should not be in the future
  if (this.completedAt && new Date(this.completedAt) > now) {
    const error = new Error('Completion time cannot be in the future');
    error.name = 'ValidationError';
    error.statusCode = 400;
    return next(error);
  }

  next();
});

// Generate appointment ID
appointmentSchema.pre('save', async function(next) {
  if (!this.appointmentId) {
    const date = new Date(this.date);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const counterId = `appointment-${year}${month}${day}`;
    const sequence = await Counter.getNextSequence(counterId);
    this.appointmentId = `APT${year}${month}${day}${String(sequence).padStart(4, '0')}`;
  }

  // Add to status history
  if (this.isModified('status')) {
    if (!this.statusHistory) {
      this.statusHistory = [];
    }
    this.statusHistory.push({
      status: this.status,
      changedAt: new Date(),
      changedBy: this.updatedBy
    });
  }

  next();
});

// Helper: Normalize time string to "HH:MM" format for consistent comparison
function normalizeTime(timeStr) {
  if (!timeStr) return null;

  // If already in HH:MM format with leading zero, return as-is
  if (/^\d{2}:\d{2}$/.test(timeStr)) return timeStr;

  // Handle "H:MM" format - add leading zero
  if (/^\d:\d{2}$/.test(timeStr)) return '0' + timeStr;

  // Handle "HH:MM:SS" format - strip seconds
  if (/^\d{2}:\d{2}:\d{2}$/.test(timeStr)) return timeStr.slice(0, 5);

  // Handle "H:MM AM/PM" or "HH:MM AM/PM" formats
  const amPmMatch = timeStr.match(/^(\d{1,2}):(\d{2})\s*(AM|PM)$/i);
  if (amPmMatch) {
    let hours = parseInt(amPmMatch[1], 10);
    const minutes = amPmMatch[2];
    const period = amPmMatch[3].toUpperCase();

    if (period === 'PM' && hours !== 12) hours += 12;
    if (period === 'AM' && hours === 12) hours = 0;

    return String(hours).padStart(2, '0') + ':' + minutes;
  }

  // Return original if no pattern matched
  return timeStr;
}

// Check for conflicts
appointmentSchema.methods.hasConflict = async function() {
  const Appointment = this.constructor;

  // Normalize times for consistent comparison
  const thisStartTime = normalizeTime(this.startTime);
  const thisEndTime = normalizeTime(this.endTime);

  // Normalize date to start of day for accurate comparison
  const appointmentDate = new Date(this.date);
  const startOfDay = new Date(appointmentDate);
  startOfDay.setHours(0, 0, 0, 0);
  const endOfDay = new Date(appointmentDate);
  endOfDay.setHours(23, 59, 59, 999);

  // Find conflicting appointments for the same provider on the same date
  const potentialConflicts = await Appointment.find({
    _id: { $ne: this._id },
    provider: this.provider,
    date: { $gte: startOfDay, $lte: endOfDay },
    status: { $nin: ['cancelled', 'no-show'] }
  }).select('startTime endTime').lean();

  // Check for time overlaps using normalized times
  for (const apt of potentialConflicts) {
    const aptStartTime = normalizeTime(apt.startTime);
    const aptEndTime = normalizeTime(apt.endTime);

    // Check for any overlap:
    // 1. Existing appointment starts during our slot
    // 2. Existing appointment ends during our slot
    // 3. Existing appointment completely contains our slot
    const startsInSlot = aptStartTime >= thisStartTime && aptStartTime < thisEndTime;
    const endsInSlot = aptEndTime > thisStartTime && aptEndTime <= thisEndTime;
    const containsSlot = aptStartTime <= thisStartTime && aptEndTime >= thisEndTime;

    if (startsInSlot || endsInSlot || containsSlot) {
      return true;
    }
  }

  return false;
};

// Send reminder
appointmentSchema.methods.sendReminder = async function(type) {
  // Implementation would depend on notification service
  // This is a placeholder for the actual implementation
  const reminder = {
    type,
    scheduledFor: new Date(),
    sent: false
  };

  this.reminders.push(reminder);
  await this.save();

  // Actual sending logic would go here
  return reminder;
};

// Calculate waiting time
appointmentSchema.methods.calculateWaitingTime = function() {
  if (this.checkInTime && this.consultationStartTime) {
    const waitTime = (this.consultationStartTime - this.checkInTime) / (1000 * 60); // in minutes
    this.waitingTime = Math.round(waitTime);
    return this.waitingTime;
  }
  return null;
};

// Post-save hook to update Patient.appointments array
appointmentSchema.post('save', async function(doc) {
  // Only add to patient's appointments array if this is a new appointment
  if (doc.wasNew && doc.patient) {
    try {
      const Patient = mongoose.model('Patient');
      await Patient.findByIdAndUpdate(
        doc.patient,
        { $addToSet: { appointments: doc._id } },
        { new: true }
      );
    } catch (err) {
      console.error('Error updating patient appointments array:', err);
    }
  }
});

// CRITICAL: Cascade appointment cancellation to associated Visit
appointmentSchema.post('save', async function(doc) {
  // Check if appointment was just cancelled and has a linked visit
  if (doc.status === 'cancelled' && doc.visit) {
    try {
      const Visit = mongoose.model('Visit');
      const visit = await Visit.findById(doc.visit);

      if (visit && visit.status !== 'completed' && visit.status !== 'cancelled') {
        visit.status = 'cancelled';
        visit.cancellation = {
          cancelled: true,
          cancelledAt: new Date(),
          reason: doc.cancellation?.reason || 'Rendez-vous annulé',
          cascadedFromAppointment: true
        };

        await visit.save();
        console.log(`Cascaded cancellation from appointment ${doc.appointmentId} to visit ${visit.visitId}`);

        // Also release any prescription reservations for this visit
        if (visit.prescriptions && visit.prescriptions.length > 0) {
          const Prescription = mongoose.model('Prescription');
          for (const prescriptionId of visit.prescriptions) {
            try {
              const prescription = await Prescription.findById(prescriptionId);
              if (prescription && prescription.status !== 'dispensed' && prescription.status !== 'cancelled') {
                prescription.status = 'cancelled';
                prescription.cancellation = {
                  cancelled: true,
                  cancelledAt: new Date(),
                  reason: 'Visite annulée'
                };
                await prescription.save();
              }
            } catch (prescErr) {
              console.error('Error cancelling prescription during appointment cancellation cascade:', prescErr);
            }
          }
        }
      }
    } catch (err) {
      console.error('Error cascading appointment cancellation to visit:', err);
    }
  }
});

// Track if document is new for post-save hook
appointmentSchema.pre('save', function(next) {
  this.wasNew = this.isNew;
  next();
});

// =====================================================
// STATUS TRANSITION STATE MACHINE
// Validates that status changes follow allowed transitions
// =====================================================

const APPOINTMENT_STATUS_TRANSITIONS = {
  'scheduled': ['confirmed', 'checked-in', 'cancelled', 'rescheduled', 'no-show'],
  'confirmed': ['checked-in', 'cancelled', 'rescheduled', 'no-show'],
  'checked-in': ['in-progress', 'cancelled', 'no-show'],
  'in-progress': ['completed', 'cancelled'],
  'completed': [], // Terminal state - no transitions allowed
  'cancelled': [], // Terminal state - no transitions allowed
  'no-show': ['rescheduled'], // Can only reschedule a no-show
  'rescheduled': ['scheduled', 'cancelled'] // Rescheduled creates new appointment
};

/**
 * Validate status transition
 * @param {string} fromStatus - Current status
 * @param {string} toStatus - New status
 * @returns {boolean} Whether transition is allowed
 */
appointmentSchema.statics.isValidTransition = function(fromStatus, toStatus) {
  if (fromStatus === toStatus) return true; // No change is always valid
  const allowedTransitions = APPOINTMENT_STATUS_TRANSITIONS[fromStatus] || [];
  return allowedTransitions.includes(toStatus);
};

/**
 * Get allowed next statuses
 * @param {string} currentStatus - Current status
 * @returns {string[]} Array of allowed next statuses
 */
appointmentSchema.statics.getAllowedTransitions = function(currentStatus) {
  return APPOINTMENT_STATUS_TRANSITIONS[currentStatus] || [];
};

// Pre-save middleware to validate status transitions
appointmentSchema.pre('save', function(next) {
  // Skip validation for new documents
  if (this.isNew) {
    return next();
  }

  // Check if status was modified
  if (!this.isModified('status')) {
    return next();
  }

  const previousStatus = this._previousStatus;
  const newStatus = this.status;

  // If we don't have previous status recorded, allow (for backwards compatibility)
  if (!previousStatus) {
    return next();
  }

  const allowedTransitions = APPOINTMENT_STATUS_TRANSITIONS[previousStatus] || [];

  if (previousStatus !== newStatus && !allowedTransitions.includes(newStatus)) {
    const error = new Error(
      `Invalid status transition from '${previousStatus}' to '${newStatus}'. ` +
      `Allowed transitions: ${allowedTransitions.join(', ') || 'none (terminal state)'}`
    );
    error.name = 'StatusTransitionError';
    error.statusCode = 400;
    return next(error);
  }

  next();
});

// Store previous status before any modifications
appointmentSchema.post('init', function() {
  this._previousStatus = this.status;
});

// Export status transitions for use in controllers
appointmentSchema.statics.STATUS_TRANSITIONS = APPOINTMENT_STATUS_TRANSITIONS;

module.exports = mongoose.model('Appointment', appointmentSchema);